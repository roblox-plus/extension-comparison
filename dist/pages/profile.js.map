{"version":3,"file":"./pages/profile.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACNA","sources":["webpack://roblox-plus/./src/js/constants/index.ts","webpack://roblox-plus/./src/js/pages/profile/details.ts","webpack://roblox-plus/./src/js/pages/profile/rap.ts","webpack://roblox-plus/./src/js/pages/profile/utils.ts","webpack://roblox-plus/./src/js/services/inventory/index.ts","webpack://roblox-plus/./src/js/services/inventory/limitedInventory.ts","webpack://roblox-plus/./src/js/services/message/index.ts","webpack://roblox-plus/./src/js/services/settings/index.ts","webpack://roblox-plus/./src/js/utils/abbreviateNumber.ts","webpack://roblox-plus/./src/js/utils/expireableDictionary.ts","webpack://roblox-plus/./src/js/utils/linkify.ts","webpack://roblox-plus/./src/js/utils/wait.ts","webpack://roblox-plus/./src/js/utils/xsrfFetch.ts","webpack://roblox-plus/webpack/bootstrap","webpack://roblox-plus/webpack/runtime/define property getters","webpack://roblox-plus/webpack/runtime/hasOwnProperty shorthand","webpack://roblox-plus/webpack/runtime/make namespace object","webpack://roblox-plus/./src/js/pages/profile/index.ts"],"sourcesContent":["const manifest = chrome.runtime.getManifest();\nconst isBackgroundPage = chrome.runtime.getURL(manifest.background?.page || '') === location.href;\nexport { manifest, isBackgroundPage };\n","import { getIdFromUrl } from '../../utils/linkify';\nconst displayNameElement = document.querySelector('.header-title>h1:first-of-type');\nconst usernameElement = document.querySelector('.profile-display-name');\nconst displayName = displayNameElement?.innerText?.trim() || '';\nconst user = {\n    id: getIdFromUrl(new URL(location.href)),\n    name: usernameElement?.innerText?.trim().substring(1) || displayName,\n    displayName,\n};\nexport { user };\n","import { getLimitedInventory } from '../../services/inventory';\nimport { getToggleSettingValue } from '../../services/settings';\nimport abbreviateNumber from '../../utils/abbreviateNumber';\nimport { user } from './details';\nimport { createStat } from './utils';\nconst getTotalInventoryValue = (limitedInventory) => {\n    let value = 0;\n    limitedInventory.forEach((item) => {\n        if (!isNaN(item.recentAveragePrice)) {\n            value += item.recentAveragePrice;\n        }\n    });\n    return value;\n};\ngetToggleSettingValue('profileRAP')\n    .then((enabled) => {\n    if (!enabled) {\n        return;\n    }\n    const inventoryValueStat = createStat('RAP', '...');\n    inventoryValueStat.parentElement?.addEventListener('click', async (event) => {\n        event.preventDefault();\n        try {\n            window.RPlus.quickInfo.trigger(location.href);\n        }\n        catch (err) {\n            console.error('Failed to open browser action', err, user);\n        }\n    });\n    getLimitedInventory(user.id)\n        .then((limitedInventory) => {\n        const value = getTotalInventoryValue(limitedInventory);\n        inventoryValueStat.setAttribute('title', `R\\$${value.toLocaleString()}`);\n        inventoryValueStat.innerText = abbreviateNumber(value);\n    })\n        .catch((err) => {\n        console.error('Failed to load limited inventory', err);\n        inventoryValueStat.parentElement?.parentElement?.remove();\n    });\n})\n    .catch((err) => {\n    console.error('Failed to check RAP setting.', err);\n});\nexport default {};\n","const headerDetails = document.querySelector('.header-details>ul.details-info');\nconst createStat = (labelText, valueText) => {\n    const container = document.createElement('li');\n    const label = document.createElement('div');\n    label.setAttribute('class', 'text-label font-caption-header');\n    label.innerText = labelText;\n    const valueLink = document.createElement('a');\n    valueLink.setAttribute('class', 'text-name');\n    const value = document.createElement('span');\n    value.setAttribute('class', 'font-header-2');\n    value.innerText = valueText;\n    container.appendChild(label);\n    container.appendChild(valueLink);\n    valueLink.appendChild(value);\n    headerDetails?.appendChild(container);\n    return value;\n};\nexport { createStat };\n","import xsrfFetch from '../../utils/xsrfFetch';\nimport { default as getLimitedInventory } from './limitedInventory';\n// Removes an asset from the authenticated user's inventory.\nconst deleteAsset = async (assetId) => {\n    const response = await xsrfFetch(new URL(`https://assetgame.roblox.com/asset/delete-from-inventory`), {\n        method: 'POST',\n        body: JSON.stringify({\n            assetId: assetId,\n        }),\n    });\n    if (!response.ok) {\n        throw new Error(`Failed to remove asset (${assetId})`);\n    }\n};\nglobalThis.inventoryService = { deleteAsset, getLimitedInventory };\nexport { deleteAsset, getLimitedInventory };\n","import ExpirableDictionary from '../../utils/expireableDictionary';\nimport wait from '../../utils/wait';\nimport { addListener, sendMessage } from '../message';\nconst messageDestination = 'inventoryService.getLimitedInventory';\nconst cache = new ExpirableDictionary(messageDestination, 5 * 60 * 1000);\n// Fetches the limited inventory for the specified user.\nconst getLimitedInventory = (userId) => {\n    return sendMessage(messageDestination, {\n        userId,\n    });\n};\n// Actually loads the inventory.\nconst loadLimitedInventory = async (userId) => {\n    const foundUserAssetIds = new Set();\n    const limitedAssets = [];\n    let nextPageCursor = '';\n    do {\n        const response = await fetch(`https://inventory.roblox.com/v1/users/${userId}/assets/collectibles?limit=100&cursor=${nextPageCursor}`);\n        if (response.status === 429) {\n            // Throttled. Wait a few seconds, and try again.\n            await wait(5000);\n            continue;\n        }\n        else if (response.status === 403) {\n            throw new Error('Inventory hidden');\n        }\n        else if (!response.ok) {\n            throw new Error('Inventory failed to load');\n        }\n        const result = await response.json();\n        nextPageCursor = result.nextPageCursor;\n        result.data.forEach((item) => {\n            const userAssetId = Number(item.userAssetId);\n            if (foundUserAssetIds.has(userAssetId)) {\n                return;\n            }\n            foundUserAssetIds.add(userAssetId);\n            limitedAssets.push({\n                userAssetId,\n                id: item.assetId,\n                name: item.name,\n                recentAveragePrice: item.recentAveragePrice\n                    ? Number(item.recentAveragePrice)\n                    : NaN,\n                serialNumber: item.serialNumber ? Number(item.serialNumber) : NaN,\n                stock: item.assetStock === 0 ? 0 : item.assetStock || undefined,\n            });\n        });\n    } while (nextPageCursor);\n    return limitedAssets;\n};\n// Listen for background messages\naddListener(messageDestination, (message) => {\n    // Check the cache\n    return cache.getOrAdd(`${message.userId}`, () => \n    // Queue up the fetch request, when not in the cache\n    loadLimitedInventory(message.userId));\n}, {\n    levelOfParallelism: 1,\n});\nexport default getLimitedInventory;\n","import { isBackgroundPage } from '../../constants';\n// All the listeners, set in the background page.\nconst listeners = {};\n// All the tabs actively connected to the message service.\nconst tabs = {};\n// An identifier that tells us which version of the messaging service we're using,\n// to ensure we don't try to process a message not intended for us.\nconst version = 2.5;\n// Send a message to a destination, and get back the result.\nconst sendMessage = async (destination, message) => {\n    return new Promise(async (resolve, reject) => {\n        const serializedMessage = JSON.stringify(message);\n        if (isBackgroundPage) {\n            // Message is from the background page, to the background page.\n            try {\n                if (listeners[destination]) {\n                    const message = JSON.parse(serializedMessage);\n                    const result = await listeners[destination](message);\n                    console.debug(`Local listener response for '${destination}':`, result, message);\n                    const data = result.data === undefined ? undefined : JSON.parse(result.data);\n                    if (result.success) {\n                        resolve(data);\n                    }\n                    else {\n                        reject(data);\n                    }\n                }\n                else {\n                    reject(`No message listener: ${destination}`);\n                }\n            }\n            catch (e) {\n                reject(e);\n            }\n        }\n        else {\n            const outboundMessage = JSON.stringify({\n                version,\n                destination,\n                message: serializedMessage,\n            });\n            console.debug(`Sending message to '${destination}'`, serializedMessage);\n            chrome.runtime.sendMessage(outboundMessage, (result) => {\n                if (result === undefined) {\n                    reject(`Unexpected message result (undefined), suggests no listener in background page.\\n\\tDestination: ${destination}`);\n                    return;\n                }\n                const data = result.data === undefined ? undefined : JSON.parse(result.data);\n                if (result.success) {\n                    resolve(data);\n                }\n                else {\n                    reject(data);\n                }\n            });\n        }\n    });\n};\n// Fetches a tab that we can send a message to, for work processing.\nconst getWorkerTab = () => {\n    const keys = Object.keys(tabs);\n    return keys.length > 0 ? tabs[keys[0]] : undefined;\n};\n// Sends a message to a tab.\nconst sendMessageToTab = async (destination, message, tab) => {\n    const serializedMessage = JSON.stringify(message);\n    const outboundMessage = JSON.stringify({\n        version,\n        destination,\n        message: serializedMessage,\n    });\n    console.debug(`Sending message to '${destination}' in tab`, serializedMessage, tab);\n    tab.postMessage(outboundMessage);\n};\n// Listen for messages at a specific destination.\nconst addListener = (destination, listener, options = {\n    levelOfParallelism: -1,\n}) => {\n    if (listeners[destination]) {\n        throw new Error(`${destination} already has message listener attached`);\n    }\n    const processMessage = async (message) => {\n        try {\n            console.debug(`Processing message for '${destination}'`, message);\n            const result = await listener(message);\n            const response = {\n                success: true,\n                data: JSON.stringify(result),\n            };\n            console.debug(`Successful message result from '${destination}':`, response, message);\n            return response;\n        }\n        catch (err) {\n            const response = {\n                success: false,\n                data: JSON.stringify(err),\n            };\n            console.debug(`Failed message result from '${destination}':`, response, message, err);\n            return response;\n        }\n    };\n    listeners[destination] = (message) => {\n        if (options.levelOfParallelism !== 1) {\n            return processMessage(message);\n        }\n        return new Promise((resolve, reject) => {\n            // https://stackoverflow.com/a/73482349/1663648\n            navigator.locks\n                .request(`messageService:${destination}`, async () => {\n                try {\n                    const result = await processMessage(message);\n                    resolve(result);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            })\n                .catch(reject);\n        });\n    };\n};\n// If we're currently in the background page, listen for messages.\nif (isBackgroundPage) {\n    chrome.runtime.onMessage.addListener((rawMessage, sender, sendResponse) => {\n        if (typeof rawMessage !== 'string') {\n            // Not for us.\n            return;\n        }\n        const fullMessage = JSON.parse(rawMessage);\n        if (fullMessage.version !== version ||\n            !fullMessage.destination ||\n            !fullMessage.message) {\n            // Not for us.\n            return;\n        }\n        const listener = listeners[fullMessage.destination];\n        if (!listener) {\n            sendResponse({\n                success: false,\n                data: JSON.stringify(`Could not route message to destination: ${fullMessage.destination}`),\n            });\n            return;\n        }\n        const message = JSON.parse(fullMessage.message);\n        listener(message)\n            .then(sendResponse)\n            .catch((err) => {\n            console.error('Listener is never expected to throw.', err, rawMessage, fullMessage);\n            sendResponse({\n                success: false,\n                data: JSON.stringify('Listener threw unhandled exception (see background page for error).'),\n            });\n        });\n        // Required for asynchronous callbacks\n        // https://stackoverflow.com/a/20077854/1663648\n        return true;\n    });\n    chrome.runtime.onConnect.addListener((port) => {\n        const id = crypto.randomUUID();\n        console.debug('Tab connected', id, port);\n        tabs[id] = port;\n        port.onDisconnect.addListener(() => {\n            console.debug('Disconnecting tab', id, port);\n            delete tabs[id];\n        });\n    });\n}\nelse {\n    console.debug(`Not attaching listener for messages, because we're not in the background.`);\n    if (!window.messageServiceConnection) {\n        const port = (window.messageServiceConnection = chrome.runtime.connect(chrome.runtime.id, {\n            name: 'messageService',\n        }));\n        port.onMessage.addListener((rawMessage) => {\n            if (typeof rawMessage !== 'string') {\n                // Not for us.\n                return;\n            }\n            const fullMessage = JSON.parse(rawMessage);\n            if (fullMessage.version !== version ||\n                !fullMessage.destination ||\n                !fullMessage.message) {\n                // Not for us.\n                return;\n            }\n            const listener = listeners[fullMessage.destination];\n            if (!listener) {\n                // No listener in this tab for this message.\n                return;\n            }\n            // We don't really have a way to communicate the response back to the service worker.\n            // So we just... do nothing with it.\n            const message = JSON.parse(fullMessage.message);\n            listener(message).catch((err) => {\n                console.error('Unhandled error processing message in tab', fullMessage, err);\n            });\n        });\n    }\n}\nglobalThis.messageService = { sendMessage, addListener, getWorkerTab, sendMessageToTab };\nexport { sendMessage, addListener, getWorkerTab, sendMessageToTab };\n","import { sendMessage, addListener } from '../message';\n// Destination to be used with messaging.\nconst messageDestinationPrefix = 'settingsService';\n// Fetches a locally stored setting value by its key.\nconst getSettingValue = (key) => {\n    return sendMessage(`${messageDestinationPrefix}.getSettingValue`, {\n        key,\n    });\n};\n// Gets a boolean setting value, toggled to false by default.\nconst getToggleSettingValue = async (key) => {\n    const value = await getSettingValue(key);\n    return !!value;\n};\n// Locally stores a setting value.\nconst setSettingValue = (key, value) => {\n    return sendMessage(`${messageDestinationPrefix}.setSettingValue`, {\n        key,\n        value,\n    });\n};\nconst getValueFromLocalStorage = (key) => {\n    if (!localStorage.hasOwnProperty(key)) {\n        return undefined;\n    }\n    try {\n        const valueArray = JSON.parse(localStorage[key]);\n        if (Array.isArray(valueArray) && valueArray.length > 0) {\n            return valueArray[0];\n        }\n        console.warn(`Setting value in localStorage invalid: ${localStorage[key]} - removing it.`);\n        localStorage.removeItem(key);\n        return undefined;\n    }\n    catch (err) {\n        console.warn(`Failed to parse '${key}' value from localStorage - removing it.`, err);\n        localStorage.removeItem(key);\n        return undefined;\n    }\n};\naddListener(`${messageDestinationPrefix}.getSettingValue`, ({ key }) => {\n    return new Promise((resolve, reject) => {\n        // chrome.storage APIs are callback-based until manifest V3.\n        // Currently in migration phase, to migrate settings from localStorage -> chrome.storage.local\n        const value = getValueFromLocalStorage(key);\n        if (value !== undefined) {\n            chrome.storage.local.set({\n                [key]: value,\n            }, () => {\n                localStorage.removeItem(key);\n                resolve(value);\n            });\n        }\n        else {\n            chrome.storage.local.get(key, (values) => {\n                resolve(values[key]);\n            });\n        }\n    });\n});\naddListener(`${messageDestinationPrefix}.setSettingValue`, ({ key, value }) => {\n    return new Promise((resolve, reject) => {\n        // chrome.storage APIs are callback-based until manifest V3.\n        // Currently in migration phase, to migrate settings from localStorage -> chrome.storage.local\n        if (value === undefined) {\n            chrome.storage.local.remove(key, () => {\n                localStorage.removeItem(key);\n                resolve(undefined);\n            });\n        }\n        else {\n            chrome.storage.local.set({\n                [key]: value,\n            }, () => {\n                localStorage.removeItem(key);\n                resolve(undefined);\n            });\n        }\n    });\n});\nglobalThis.settingsService = { getSettingValue, getToggleSettingValue, setSettingValue };\nexport { getSettingValue, getToggleSettingValue, setSettingValue };\n","// All the values to abbreviate a number at.\nconst abbreviations = [\n    {\n        value: 1000,\n        abbreviation: 'K',\n    },\n    {\n        value: 1000000,\n        abbreviation: 'M',\n    },\n    {\n        value: 1000000000,\n        abbreviation: 'B',\n    },\n    {\n        value: 1000000000000,\n        abbreviation: 'T',\n    },\n];\nexport { abbreviations };\n// Abbreviates a number, for human readability, after it surpasses a given value (or after 1,000 if not provided).\nexport default (value, abbreviateAt) => {\n    if (!abbreviateAt) {\n        abbreviateAt = abbreviations[0].value;\n    }\n    if (value >= abbreviateAt) {\n        for (let i = abbreviations.length - 1; i >= 0; i--) {\n            if (value >= abbreviations[i].value) {\n                return `${Math.floor(value / abbreviations[i].value).toLocaleString()}${abbreviations[i].abbreviation}+`;\n            }\n        }\n    }\n    return value.toLocaleString();\n};\n","// This class can be used to concurrently cache items, or fetch their values.\nclass ExpirableDictionary {\n    lockKey;\n    expirationInMilliseconds;\n    // The items that are in the dictionary.\n    items = {};\n    constructor(\n    // A name for the dictionary, used for locking.\n    name, \n    // How long the item will remain in the dictionary, in milliseconds.\n    expirationInMilliseconds) {\n        this.lockKey = `ExpirableDictionary:${name}`;\n        this.expirationInMilliseconds = expirationInMilliseconds;\n    }\n    // Tries to fetch an item by its key from the dictionary, or it will call the value factory to add it in.\n    getOrAdd(key, valueFactory) {\n        const item = this.items[key];\n        if (item !== undefined) {\n            return Promise.resolve(item);\n        }\n        return new Promise((resolve, reject) => {\n            navigator.locks\n                .request(`${this.lockKey}:${key}`, async () => {\n                // It's possible the item was added since we requested the lock, check again.\n                const item = this.items[key];\n                if (item !== undefined) {\n                    resolve(item);\n                    return;\n                }\n                try {\n                    const value = (this.items[key] = await valueFactory());\n                    setTimeout(() => this.evict(key), this.expirationInMilliseconds);\n                    resolve(value);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            })\n                .catch(reject);\n        });\n    }\n    evict(key) {\n        delete this.items[key];\n    }\n}\nexport default ExpirableDictionary;\n","const getSEOLink = (id, name, path) => {\n    if (!name) {\n        name = 'redirect';\n    }\n    else {\n        name =\n            name\n                .replace(/'/g, '')\n                .replace(/\\W+/g, '-')\n                .replace(/^-+/, '')\n                .replace(/-+$/, '') || 'redirect';\n    }\n    return new URL(`https://www.roblox.com/${path}/${id}/${name}`);\n};\nconst getCatalogLink = (assetId, assetName) => {\n    return getSEOLink(assetId, assetName, 'catalog');\n};\nconst getLibraryLink = (assetId, assetName) => {\n    return getSEOLink(assetId, assetName, 'library');\n};\nconst getPlaceLink = (placeId, placeName) => {\n    return getSEOLink(placeId, placeName, 'games');\n};\nconst getUserProfileLink = (userId) => {\n    return getSEOLink(userId, 'profile', 'users');\n};\nconst getIdFromUrl = (url) => {\n    const match = url.pathname.match(/^\\/(badges|games|game-pass|groups|catalog|library|users)\\/(\\d+)\\//i) || [];\n    // Returns NaN if the URL doesn't match.\n    return Number(match[2]);\n};\nexport { getCatalogLink, getLibraryLink, getPlaceLink, getUserProfileLink, getIdFromUrl, };\n","export default (time) => {\n    return new Promise((resolve, reject) => {\n        setTimeout(resolve, time);\n    });\n};\n","const headerName = 'X-CSRF-Token';\nlet xsrfToken = '';\n// A fetch request which will attach an X-CSRF-Token in all outbound requests.\nconst xsrfFetch = async (url, requestDetails) => {\n    if (url.hostname.endsWith('.roblox.com')) {\n        if (!requestDetails) {\n            requestDetails = {};\n        }\n        requestDetails.credentials = 'include';\n        if (!requestDetails.headers) {\n            requestDetails.headers = new Headers();\n        }\n        if (requestDetails.headers instanceof Headers) {\n            if (xsrfToken) {\n                requestDetails.headers.set(headerName, xsrfToken);\n            }\n            if (requestDetails.body && !requestDetails.headers.has('Content-Type')) {\n                requestDetails.headers.set('Content-Type', 'application/json');\n            }\n        }\n    }\n    const response = await fetch(url, requestDetails);\n    const token = response.headers.get(headerName);\n    if (response.ok || !token) {\n        return response;\n    }\n    xsrfToken = token;\n    return xsrfFetch(url, requestDetails);\n};\nexport default xsrfFetch;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export { default as rap } from './rap';\n"],"names":[],"sourceRoot":""}