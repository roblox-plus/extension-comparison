{"version":3,"file":"./pages/game-pass-details.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5SA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://roblox-plus/./libs/extension-messaging/dist/constants.js","webpack://roblox-plus/./libs/extension-messaging/dist/index.js","webpack://roblox-plus/./libs/extension-utils/dist/constants/index.js","webpack://roblox-plus/./libs/extension-utils/dist/enums/loading-state.js","webpack://roblox-plus/./libs/extension-utils/dist/index.js","webpack://roblox-plus/./libs/extension-utils/dist/utils/wait.js","webpack://roblox-plus/./libs/roblox/dist/enums/asset-type.js","webpack://roblox-plus/./libs/roblox/dist/enums/presence-type.js","webpack://roblox-plus/./libs/roblox/dist/enums/thumbnail-state.js","webpack://roblox-plus/./libs/roblox/dist/enums/thumbnail-type.js","webpack://roblox-plus/./libs/roblox/dist/enums/trade-status-type.js","webpack://roblox-plus/./libs/roblox/dist/index.js","webpack://roblox-plus/./libs/roblox/dist/utils/linkify.js","webpack://roblox-plus/./src/js/pages/game-pass-details/details.ts","webpack://roblox-plus/./src/js/pages/item-details/stats.ts","webpack://roblox-plus/./src/js/services/game-passes/get-game-pass-sale-count.ts","webpack://roblox-plus/./src/js/services/game-passes/index.ts","webpack://roblox-plus/./src/js/services/localization/index.ts","webpack://roblox-plus/./src/js/services/settings/index.ts","webpack://roblox-plus/./src/js/utils/expireableDictionary.ts","webpack://roblox-plus/webpack/bootstrap","webpack://roblox-plus/webpack/runtime/define property getters","webpack://roblox-plus/webpack/runtime/hasOwnProperty shorthand","webpack://roblox-plus/webpack/runtime/make namespace object","webpack://roblox-plus/./src/js/pages/game-pass-details/index.ts"],"sourcesContent":["// An identifier that tells us which version of the messaging service we're using,\n// to ensure we don't try to process a message not intended for us.\nconst version = 2.5;\nexport { version };\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar _a;\nimport { isServiceWorker } from '@tix-factory/extension-utils';\nimport { version } from './constants';\n// All the listeners, set in the background page.\nconst listeners = {};\n// Keep track of all the listeners that accept external calls.\nconst externalListeners = {};\nconst externalResponseHandlers = {};\n// Send a message to a destination, and get back the result.\nconst sendMessage = (destination, message, external) => __awaiter(void 0, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {\n        var _b;\n        const serializedMessage = JSON.stringify(message);\n        if (isServiceWorker) {\n            // Message is from the background page, to the background page.\n            try {\n                if (listeners[destination]) {\n                    const message = JSON.parse(serializedMessage);\n                    const result = yield listeners[destination](message);\n                    console.debug(`Local listener response for '${destination}':`, result, message);\n                    const data = result.data === undefined ? undefined : JSON.parse(result.data);\n                    if (result.success) {\n                        resolve(data);\n                    }\n                    else {\n                        reject(data);\n                    }\n                }\n                else {\n                    reject(`No message listener: ${destination}`);\n                }\n            }\n            catch (e) {\n                reject(e);\n            }\n        }\n        else if (chrome === null || chrome === void 0 ? void 0 : chrome.runtime) {\n            // Message is being sent from the content script\n            const outboundMessage = JSON.stringify({\n                version,\n                destination,\n                external,\n                message: serializedMessage,\n            });\n            console.debug(`Sending message to '${destination}'`, serializedMessage);\n            chrome.runtime.sendMessage(outboundMessage, (result) => {\n                if (result === undefined) {\n                    reject(`Unexpected message result (undefined), suggests no listener in background page.\\n\\tDestination: ${destination}`);\n                    return;\n                }\n                const data = result.data === undefined ? undefined : JSON.parse(result.data);\n                if (result.success) {\n                    resolve(data);\n                }\n                else {\n                    reject(data);\n                }\n            });\n        }\n        else if ((_b = document.body) === null || _b === void 0 ? void 0 : _b.dataset.extensionId) {\n            // Message is being sent by the native browser tab.\n            const messageId = crypto.randomUUID();\n            const timeout = setTimeout(() => {\n                if (externalResponseHandlers[messageId]) {\n                    delete externalResponseHandlers[messageId];\n                    reject(`Message timed out trying to contact extension`);\n                }\n            }, 15 * 1000);\n            externalResponseHandlers[messageId] = {\n                resolve: (result) => {\n                    clearTimeout(timeout);\n                    delete externalResponseHandlers[messageId];\n                    resolve(result);\n                },\n                reject: (error) => {\n                    clearTimeout(timeout);\n                    delete externalResponseHandlers[messageId];\n                    reject(error);\n                },\n            };\n            globalThis.postMessage({\n                version,\n                extensionId: document.body.dataset.extensionId,\n                destination,\n                message,\n                messageId,\n            });\n        }\n        else {\n            reject(`Could not find a way to transport the message to the extension.`);\n        }\n    }));\n});\n// Listen for messages at a specific destination.\nconst addListener = (destination, listener, options = {\n    levelOfParallelism: -1,\n}) => {\n    if (listeners[destination]) {\n        throw new Error(`${destination} already has message listener attached`);\n    }\n    const processMessage = (message) => __awaiter(void 0, void 0, void 0, function* () {\n        try {\n            console.debug(`Processing message for '${destination}'`, message);\n            const result = yield listener(message);\n            const response = {\n                success: true,\n                data: JSON.stringify(result),\n            };\n            console.debug(`Successful message result from '${destination}':`, response, message);\n            return response;\n        }\n        catch (err) {\n            const response = {\n                success: false,\n                data: JSON.stringify(err),\n            };\n            console.debug(`Failed message result from '${destination}':`, response, message, err);\n            return response;\n        }\n    });\n    listeners[destination] = (message) => {\n        if (options.levelOfParallelism !== 1) {\n            return processMessage(message);\n        }\n        return new Promise((resolve, reject) => {\n            // https://stackoverflow.com/a/73482349/1663648\n            navigator.locks\n                .request(`messageService:${destination}`, () => __awaiter(void 0, void 0, void 0, function* () {\n                try {\n                    const result = yield processMessage(message);\n                    resolve(result);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            }))\n                .catch(reject);\n        });\n    };\n    if (options.allowExternalConnections) {\n        externalListeners[destination] = true;\n    }\n};\n// If we're currently in the background page, listen for messages.\nif (isServiceWorker) {\n    chrome.runtime.onMessage.addListener((rawMessage, sender, sendResponse) => {\n        if (typeof rawMessage !== 'string') {\n            // Not for us.\n            return;\n        }\n        const fullMessage = JSON.parse(rawMessage);\n        if (fullMessage.version !== version ||\n            !fullMessage.destination ||\n            !fullMessage.message) {\n            // Not for us.\n            return;\n        }\n        if (fullMessage.external && !externalListeners[fullMessage.destination]) {\n            sendResponse({\n                success: false,\n                data: JSON.stringify('Listener does not accept external callers.'),\n            });\n            return;\n        }\n        const listener = listeners[fullMessage.destination];\n        if (!listener) {\n            sendResponse({\n                success: false,\n                data: JSON.stringify(`Could not route message to destination: ${fullMessage.destination}`),\n            });\n            return;\n        }\n        const message = JSON.parse(fullMessage.message);\n        listener(message)\n            .then(sendResponse)\n            .catch((err) => {\n            console.error('Listener is never expected to throw.', err, rawMessage, fullMessage);\n            sendResponse({\n                success: false,\n                data: JSON.stringify('Listener threw unhandled exception (see background page for error).'),\n            });\n        });\n        // Required for asynchronous callbacks\n        // https://stackoverflow.com/a/20077854/1663648\n        return true;\n    });\n}\nelse if ((_a = globalThis.chrome) === null || _a === void 0 ? void 0 : _a.runtime) {\n    console.debug(`Not attaching listener for messages, because we're not in the background.`);\n    if (!globalThis.messageServiceConnection) {\n        const port = (globalThis.messageServiceConnection = chrome.runtime.connect(chrome.runtime.id, {\n            name: 'messageService',\n        }));\n        port.onMessage.addListener((rawMessage) => {\n            if (typeof rawMessage !== 'string') {\n                // Not for us.\n                return;\n            }\n            const fullMessage = JSON.parse(rawMessage);\n            if (fullMessage.version !== version ||\n                !fullMessage.destination ||\n                !fullMessage.message) {\n                // Not for us.\n                return;\n            }\n            const listener = listeners[fullMessage.destination];\n            if (!listener) {\n                // No listener in this tab for this message.\n                return;\n            }\n            // We don't really have a way to communicate the response back to the service worker.\n            // So we just... do nothing with it.\n            const message = JSON.parse(fullMessage.message);\n            listener(message).catch((err) => {\n                console.error('Unhandled error processing message in tab', fullMessage, err);\n            });\n        });\n    }\n    // chrome.runtime is available, and we got a message from the window\n    // this could be a tab trying to get information from the extension\n    globalThis.addEventListener('message', (messageEvent) => __awaiter(void 0, void 0, void 0, function* () {\n        const { extensionId, messageId, destination, message } = messageEvent.data;\n        if (extensionId !== chrome.runtime.id ||\n            !messageId ||\n            !destination ||\n            !message) {\n            // They didn't want to contact us.\n            // Or if they did, they didn't have the required fields.\n            return;\n        }\n        if (messageEvent.data.version !== version) {\n            // They did want to contact us, but there was a version mismatch.\n            // We can't handle this message.\n            globalThis.postMessage({\n                extensionId,\n                messageId,\n                success: false,\n                data: `Extension message receiver is incompatible with message sender`,\n            });\n            return;\n        }\n        console.debug('Received message for', destination, message);\n        try {\n            const response = yield sendMessage(destination, message, true);\n            // Success! Now go tell the client they got everything they wanted.\n            globalThis.postMessage({\n                extensionId,\n                messageId,\n                success: true,\n                data: response,\n            });\n        }\n        catch (e) {\n            console.debug('Failed to send message to', destination, e);\n            // :coffin:\n            globalThis.postMessage({\n                extensionId,\n                messageId,\n                success: false,\n                data: e,\n            });\n        }\n    }));\n}\nelse {\n    // Not a background page, and not a content script.\n    // This could be a page where we want to listen for calls from the tab.\n    globalThis.addEventListener('message', (messageEvent) => {\n        const { extensionId, messageId, success, data } = messageEvent.data;\n        if (extensionId !== document.body.dataset.extensionId ||\n            !messageId ||\n            typeof success !== 'boolean') {\n            // Not for us.\n            return;\n        }\n        // Check to see if we have a handler waiting for this message response...\n        const responseHandler = externalResponseHandlers[messageId];\n        if (!responseHandler) {\n            console.warn('We got a response back for a message we no longer have a handler for.', extensionId, messageId, success, data);\n            return;\n        }\n        // Yay! Tell the krustomer we have their data, from the extension.\n        console.debug('We received a response for', messageId, success, data);\n        if (success) {\n            responseHandler.resolve(data);\n        }\n        else {\n            responseHandler.reject(data);\n        }\n    });\n}\nexport { addListener, sendMessage };\n","var _a, _b;\nconst manifest = (_b = (_a = globalThis.chrome) === null || _a === void 0 ? void 0 : _a.runtime) === null || _b === void 0 ? void 0 : _b.getManifest();\nconst isServiceWorker = !globalThis.window;\nexport { isServiceWorker, manifest };\n","// A generic loading state enum.\nvar LoadingState;\n(function (LoadingState) {\n    LoadingState[\"Loading\"] = \"Loading\";\n    LoadingState[\"Success\"] = \"Success\";\n    LoadingState[\"Error\"] = \"Error\";\n})(LoadingState || (LoadingState = {}));\nexport default LoadingState;\n","// Export constants\nexport * from './constants';\n// Export enums\nexport { default as LoadingState } from './enums/loading-state';\n// Export utils\nexport { default as wait } from './utils/wait';\n","const wait = (time) => {\n    return new Promise((resolve, reject) => {\n        setTimeout(resolve, time);\n    });\n};\nexport default wait;\n","var AssetType;\n(function (AssetType) {\n    AssetType[AssetType[\"Image\"] = 1] = \"Image\";\n    AssetType[AssetType[\"TShirt\"] = 2] = \"TShirt\";\n    AssetType[AssetType[\"Audio\"] = 3] = \"Audio\";\n    AssetType[AssetType[\"Mesh\"] = 4] = \"Mesh\";\n    AssetType[AssetType[\"Lua\"] = 5] = \"Lua\";\n    AssetType[AssetType[\"Html\"] = 6] = \"Html\";\n    AssetType[AssetType[\"Text\"] = 7] = \"Text\";\n    AssetType[AssetType[\"Hat\"] = 8] = \"Hat\";\n    AssetType[AssetType[\"Place\"] = 9] = \"Place\";\n    AssetType[AssetType[\"Model\"] = 10] = \"Model\";\n    AssetType[AssetType[\"Shirt\"] = 11] = \"Shirt\";\n    AssetType[AssetType[\"Pants\"] = 12] = \"Pants\";\n    AssetType[AssetType[\"Decal\"] = 13] = \"Decal\";\n    AssetType[AssetType[\"Avatar\"] = 16] = \"Avatar\";\n    AssetType[AssetType[\"Head\"] = 17] = \"Head\";\n    AssetType[AssetType[\"Face\"] = 18] = \"Face\";\n    AssetType[AssetType[\"Gear\"] = 19] = \"Gear\";\n    AssetType[AssetType[\"Badge\"] = 21] = \"Badge\";\n    AssetType[AssetType[\"GroupEmblem\"] = 22] = \"GroupEmblem\";\n    AssetType[AssetType[\"Animation\"] = 24] = \"Animation\";\n    AssetType[AssetType[\"Arms\"] = 25] = \"Arms\";\n    AssetType[AssetType[\"Legs\"] = 26] = \"Legs\";\n    AssetType[AssetType[\"Torso\"] = 27] = \"Torso\";\n    AssetType[AssetType[\"RightArm\"] = 28] = \"RightArm\";\n    AssetType[AssetType[\"LeftArm\"] = 29] = \"LeftArm\";\n    AssetType[AssetType[\"LeftLeg\"] = 30] = \"LeftLeg\";\n    AssetType[AssetType[\"RightLeg\"] = 31] = \"RightLeg\";\n    AssetType[AssetType[\"Package\"] = 32] = \"Package\";\n    AssetType[AssetType[\"YouTubeVideo\"] = 33] = \"YouTubeVideo\";\n    AssetType[AssetType[\"GamePass\"] = 34] = \"GamePass\";\n    AssetType[AssetType[\"App\"] = 35] = \"App\";\n    AssetType[AssetType[\"Code\"] = 37] = \"Code\";\n    AssetType[AssetType[\"Plugin\"] = 38] = \"Plugin\";\n    AssetType[AssetType[\"SolidModel\"] = 39] = \"SolidModel\";\n    AssetType[AssetType[\"MeshPart\"] = 40] = \"MeshPart\";\n    AssetType[AssetType[\"HairAccessory\"] = 41] = \"HairAccessory\";\n    AssetType[AssetType[\"FaceAccessory\"] = 42] = \"FaceAccessory\";\n    AssetType[AssetType[\"NeckAccessory\"] = 43] = \"NeckAccessory\";\n    AssetType[AssetType[\"ShoulderAccessory\"] = 44] = \"ShoulderAccessory\";\n    AssetType[AssetType[\"FrontAccessory\"] = 45] = \"FrontAccessory\";\n    AssetType[AssetType[\"BackAccessory\"] = 46] = \"BackAccessory\";\n    AssetType[AssetType[\"WaistAccessory\"] = 47] = \"WaistAccessory\";\n    AssetType[AssetType[\"ClimbAnimation\"] = 48] = \"ClimbAnimation\";\n    AssetType[AssetType[\"DeathAnimation\"] = 49] = \"DeathAnimation\";\n    AssetType[AssetType[\"FallAnimation\"] = 50] = \"FallAnimation\";\n    AssetType[AssetType[\"IdleAnimation\"] = 51] = \"IdleAnimation\";\n    AssetType[AssetType[\"JumpAnimation\"] = 52] = \"JumpAnimation\";\n    AssetType[AssetType[\"RunAnimation\"] = 53] = \"RunAnimation\";\n    AssetType[AssetType[\"SwimAnimation\"] = 54] = \"SwimAnimation\";\n    AssetType[AssetType[\"WalkAnimation\"] = 55] = \"WalkAnimation\";\n    AssetType[AssetType[\"PoseAnimation\"] = 56] = \"PoseAnimation\";\n    AssetType[AssetType[\"EarAccessory\"] = 57] = \"EarAccessory\";\n    AssetType[AssetType[\"EyeAccessory\"] = 58] = \"EyeAccessory\";\n    AssetType[AssetType[\"LocalizationTableManifest\"] = 59] = \"LocalizationTableManifest\";\n    AssetType[AssetType[\"LocalizationTableTranslation\"] = 60] = \"LocalizationTableTranslation\";\n    AssetType[AssetType[\"Emote\"] = 61] = \"Emote\";\n    AssetType[AssetType[\"Video\"] = 62] = \"Video\";\n    AssetType[AssetType[\"TexturePack\"] = 63] = \"TexturePack\";\n    AssetType[AssetType[\"TShirtAccessory\"] = 64] = \"TShirtAccessory\";\n    AssetType[AssetType[\"ShirtAccessory\"] = 65] = \"ShirtAccessory\";\n    AssetType[AssetType[\"PantsAccessory\"] = 66] = \"PantsAccessory\";\n    AssetType[AssetType[\"JacketAccessory\"] = 67] = \"JacketAccessory\";\n    AssetType[AssetType[\"SweaterAccessory\"] = 68] = \"SweaterAccessory\";\n    AssetType[AssetType[\"ShortsAccessory\"] = 69] = \"ShortsAccessory\";\n    AssetType[AssetType[\"LeftShoeAccessory\"] = 70] = \"LeftShoeAccessory\";\n    AssetType[AssetType[\"RightShoeAccessory\"] = 71] = \"RightShoeAccessory\";\n    AssetType[AssetType[\"DressSkirtAccessory\"] = 72] = \"DressSkirtAccessory\";\n    AssetType[AssetType[\"FontFamily\"] = 73] = \"FontFamily\";\n    AssetType[AssetType[\"FontFace\"] = 74] = \"FontFace\";\n    AssetType[AssetType[\"MeshHiddenSurfaceRemoval\"] = 75] = \"MeshHiddenSurfaceRemoval\";\n    AssetType[AssetType[\"EyebrowAccessory\"] = 76] = \"EyebrowAccessory\";\n    AssetType[AssetType[\"EyelashAccessory\"] = 77] = \"EyelashAccessory\";\n    AssetType[AssetType[\"MoodAnimation\"] = 78] = \"MoodAnimation\";\n    AssetType[AssetType[\"DynamicHead\"] = 79] = \"DynamicHead\";\n})(AssetType || (AssetType = {}));\nexport default AssetType;\n","// The types of user presence.\nvar PresenceType;\n(function (PresenceType) {\n    // The user is offline.\n    PresenceType[\"Offline\"] = \"Offline\";\n    // The user is online.\n    PresenceType[\"Online\"] = \"Online\";\n    // The user is currently in an experience.\n    PresenceType[\"Experience\"] = \"Experience\";\n    // The user is currently in Roblox Studio.\n    PresenceType[\"Studio\"] = \"Studio\";\n})(PresenceType || (PresenceType = {}));\nexport default PresenceType;\n","// Possible states for a thumbnail to be in.\nvar ThumbnailState;\n(function (ThumbnailState) {\n    // The thumbnail had an unexpected error trying to load.\n    ThumbnailState[\"Error\"] = \"Error\";\n    // The thumbnailed loaded successfully.\n    ThumbnailState[\"Completed\"] = \"Completed\";\n    // The thumbnail is currently in review.\n    ThumbnailState[\"InReview\"] = \"InReview\";\n    // The thumbnail is pending, and should be retried.\n    ThumbnailState[\"Pending\"] = \"Pending\";\n    // The thumbnail is blocked.\n    ThumbnailState[\"Blocked\"] = \"Blocked\";\n    // The thumbnail is temporarily unavailable.\n    ThumbnailState[\"TemporarilyUnavailable\"] = \"TemporarilyUnavailable\";\n})(ThumbnailState || (ThumbnailState = {}));\nexport default ThumbnailState;\n","// The types of thumbnails that can be requested.\nvar ThumbnailType;\n(function (ThumbnailType) {\n    // An avatar head shot thumbnail.\n    ThumbnailType[\"AvatarHeadShot\"] = \"AvatarHeadShot\";\n    // The thumbnail for an asset.\n    ThumbnailType[\"Asset\"] = \"Asset\";\n    // The icon for a group.\n    ThumbnailType[\"GroupIcon\"] = \"GroupIcon\";\n    // The icon for a game pass.\n    ThumbnailType[\"GamePass\"] = \"GamePass\";\n    // The icon for a developer product.\n    ThumbnailType[\"DeveloperProduct\"] = \"DeveloperProduct\";\n    // The icon for a game.\n    ThumbnailType[\"GameIcon\"] = \"GameIcon\";\n})(ThumbnailType || (ThumbnailType = {}));\nexport default ThumbnailType;\n","var TradeStatusType;\n(function (TradeStatusType) {\n    TradeStatusType[\"Inbound\"] = \"Inbound\";\n    TradeStatusType[\"Outbound\"] = \"Outbound\";\n    TradeStatusType[\"Completed\"] = \"Completed\";\n    TradeStatusType[\"Inactive\"] = \"Inactive\";\n})(TradeStatusType || (TradeStatusType = {}));\nexport default TradeStatusType;\n","// Export enums\nexport { default as AssetType } from './enums/asset-type';\nexport { default as PresenceType } from './enums/presence-type';\nexport { default as ThumbnailState } from './enums/thumbnail-state';\nexport { default as ThumbnailType } from './enums/thumbnail-type';\nexport { default as TradeStatusType } from './enums/trade-status-type';\n// Export utils\nexport * from './utils/linkify';\n","const getSEOLink = (id, name, path) => {\n    if (!name) {\n        name = 'redirect';\n    }\n    else {\n        name =\n            name\n                .replace(/'/g, '')\n                .replace(/\\W+/g, '-')\n                .replace(/^-+/, '')\n                .replace(/-+$/, '') || 'redirect';\n    }\n    return new URL(`https://www.roblox.com/${path}/${id}/${name}`);\n};\nconst getGroupLink = (groupId, groupName) => {\n    return getSEOLink(groupId, groupName, 'groups');\n};\nconst getGamePassLink = (gamePassId, gamePassName) => {\n    return getSEOLink(gamePassId, gamePassName, 'game-pass');\n};\nconst getCatalogLink = (assetId, assetName) => {\n    return getSEOLink(assetId, assetName, 'catalog');\n};\nconst getLibraryLink = (assetId, assetName) => {\n    return getSEOLink(assetId, assetName, 'library');\n};\nconst getPlaceLink = (placeId, placeName) => {\n    return getSEOLink(placeId, placeName, 'games');\n};\nconst getUserProfileLink = (userId) => {\n    return getSEOLink(userId, 'profile', 'users');\n};\nconst getIdFromUrl = (url) => {\n    const match = url.pathname.match(/^\\/(badges|games|game-pass|groups|catalog|library|users)\\/(\\d+)\\/?/i) || [];\n    // Returns NaN if the URL doesn't match.\n    return Number(match[2]);\n};\nexport { getCatalogLink, getGamePassLink, getGroupLink, getIdFromUrl, getLibraryLink, getPlaceLink, getUserProfileLink, };\n","import { getIdFromUrl } from 'roblox';\nconst gamePassId = Number(getIdFromUrl(new URL(location.href)));\nconst isOwnCreatedItem = !!document.querySelector('#configure-item');\nexport { gamePassId, isOwnCreatedItem };\n","const getItemTypeStat = () => {\n    // Game pass details page has this format.\n    const itemTypeStat = document.querySelector('.item-details .item-type-field-container');\n    if (itemTypeStat instanceof HTMLElement) {\n        return [\n            itemTypeStat,\n            'clearfix item-field-container',\n            'text-subheader text-label text-overflow field-label',\n            'field-content',\n        ];\n    }\n    // Item details page has this format sometimes.\n    const itemTypeSpan = document.querySelectorAll('#type-content');\n    if (itemTypeSpan.length > 0 &&\n        itemTypeSpan[itemTypeSpan.length - 1] instanceof HTMLElement) {\n        return [\n            itemTypeSpan[itemTypeSpan.length - 1].parentElement,\n            'clearfix item-info-row-container',\n            'font-header-1 text-subheader text-label text-overflow row-label',\n            'font-body text',\n        ];\n    }\n    return [null, '', '', ''];\n};\nconst createStat = (label, value) => {\n    const [itemTypeStat, containerClassName, labelClassName, valueClassName] = getItemTypeStat();\n    if (!itemTypeStat) {\n        return;\n    }\n    const container = document.createElement('div');\n    container.setAttribute('class', containerClassName);\n    const labelElement = document.createElement('div');\n    labelElement.setAttribute('class', labelClassName);\n    labelElement.innerText = label;\n    const valueElement = document.createElement('span');\n    valueElement.setAttribute('class', valueClassName);\n    valueElement.innerText = value;\n    container.appendChild(labelElement);\n    container.appendChild(valueElement);\n    itemTypeStat.after(container);\n};\nexport { createStat };\n","import { addListener, sendMessage } from '@tix-factory/extension-messaging';\nimport ExpirableDictionary from '../../utils/expireableDictionary';\nconst messageDestination = 'gamePassesService.getGamePassSaleCount';\nconst cache = new ExpirableDictionary(messageDestination, 30 * 1000);\nconst getGamePassSaleCount = async (gamePassId) => {\n    return sendMessage(messageDestination, { gamePassId });\n};\nconst loadGamePassSales = async (gamePassId) => {\n    const response = await fetch(`https://economy.roblox.com/v1/game-pass/${gamePassId}/game-pass-product-info`);\n    if (!response.ok) {\n        throw new Error('Failed to load game pass product info');\n    }\n    const result = await response.json();\n    return result.Sales || NaN;\n};\n// Listen for messages sent to the service worker.\naddListener(messageDestination, (message) => {\n    // Check the cache\n    return cache.getOrAdd(`${message.gamePassId}`, () => \n    // Queue up the fetch request, when not in the cache\n    loadGamePassSales(message.gamePassId));\n}, {\n    levelOfParallelism: 1,\n});\nexport default getGamePassSaleCount;\n","import getGamePassSaleCount from './get-game-pass-sale-count';\nglobalThis.gamePassesService = { getGamePassSaleCount };\nexport { getGamePassSaleCount };\n","import { addListener, sendMessage } from '@tix-factory/extension-messaging';\nconst englishLocale = 'en_us';\nconst messageDestination = 'localizationService.getTranslationResources';\nlet translationResourceCache = [];\nlet localeCache = '';\n// Gets the locale for the authenticated user.\nconst getAuthenticatedUserLocale = async () => {\n    if (localeCache) {\n        return localeCache;\n    }\n    try {\n        const response = await fetch(`https://locale.roblox.com/v1/locales/user-locale`);\n        if (!response.ok) {\n            console.warn('Failed to fetch user locale - defaulting to English.', response.status);\n            return (localeCache = englishLocale);\n        }\n        const result = await response.json();\n        return (localeCache = result.supportedLocale.locale);\n    }\n    catch (e) {\n        console.warn('Unhandled error loading user locale - defaulting to English.', e);\n        return (localeCache = englishLocale);\n    }\n};\n// Fetches all the translation resources for the authenticated user.\nconst getTranslationResources = async () => {\n    if (translationResourceCache.length > 0) {\n        return translationResourceCache;\n    }\n    return (translationResourceCache = await sendMessage(messageDestination, {}));\n};\n// Fetches an individual translation resource.\nconst getTranslationResource = async (namespace, key) => {\n    const translationResources = await getTranslationResources();\n    const resource = translationResources.find((r) => r.namespace === namespace && r.key === key);\n    if (!resource) {\n        console.warn(`No translation resource available.\\n\\tNamespace: ${namespace}\\n\\tKey: ${key}`);\n    }\n    return resource?.value || '';\n};\nconst getTranslationResourceWithFallback = async (namespace, key, defaultValue) => {\n    try {\n        const value = await getTranslationResource(namespace, key);\n        if (!value) {\n            return defaultValue;\n        }\n        return value;\n    }\n    catch (e) {\n        console.warn('Failed to load translation resource', namespace, key, e);\n        return defaultValue;\n    }\n};\n// Listener to ensure these always happen in the background, for strongest caching potential.\naddListener(messageDestination, async () => {\n    if (translationResourceCache.length > 0) {\n        return translationResourceCache;\n    }\n    const locale = await getAuthenticatedUserLocale();\n    const response = await fetch(`https://translations.roblox.com/v1/translations?consumerType=Web`);\n    if (!response.ok) {\n        throw new Error(`Failed to load translation resources (${response.status})`);\n    }\n    const result = await response.json();\n    const resourcesUrl = result.data.find((r) => r.locale === locale) ||\n        result.data.find((r) => r.locale === englishLocale);\n    if (!resourcesUrl) {\n        throw new Error(`Failed to find translation resources for locale (${locale})`);\n    }\n    const resources = await fetch(resourcesUrl.url);\n    const resourcesJson = await resources.json();\n    return (translationResourceCache = resourcesJson.contents.map((r) => {\n        return {\n            namespace: r.namespace,\n            key: r.key,\n            value: r.translation || r.english,\n        };\n    }));\n}, {\n    // Ensure that multiple requests for this information can't be processed at once.\n    levelOfParallelism: 1,\n});\nglobalThis.localizationService = { getTranslationResource, getTranslationResourceWithFallback };\nexport { getTranslationResource, getTranslationResourceWithFallback };\n","import { addListener, sendMessage } from '@tix-factory/extension-messaging';\n// Destination to be used with messaging.\nconst messageDestinationPrefix = 'settingsService';\n// Fetches a locally stored setting value by its key.\nconst getSettingValue = (key) => {\n    return sendMessage(`${messageDestinationPrefix}.getSettingValue`, {\n        key,\n    });\n};\n// Gets a boolean setting value, toggled to false by default.\nconst getToggleSettingValue = async (key) => {\n    const value = await getSettingValue(key);\n    return !!value;\n};\n// Locally stores a setting value.\nconst setSettingValue = (key, value) => {\n    return sendMessage(`${messageDestinationPrefix}.setSettingValue`, {\n        key,\n        value,\n    });\n};\naddListener(`${messageDestinationPrefix}.getSettingValue`, async ({ key }) => {\n    const values = await chrome.storage.local.get(key);\n    return values[key];\n}, {\n    levelOfParallelism: -1,\n    allowExternalConnections: true,\n});\naddListener(`${messageDestinationPrefix}.setSettingValue`, async ({ key, value }) => {\n    if (value) {\n        await chrome.storage.local.set({\n            [key]: value,\n        });\n    }\n    else {\n        await chrome.storage.local.remove(key);\n    }\n}, {\n    levelOfParallelism: -1,\n    allowExternalConnections: true,\n});\nglobalThis.settingsService = { getSettingValue, getToggleSettingValue, setSettingValue };\nexport { getSettingValue, getToggleSettingValue, setSettingValue };\n","// This class can be used to concurrently cache items, or fetch their values.\nclass ExpirableDictionary {\n    lockKey;\n    expirationInMilliseconds;\n    // The items that are in the dictionary.\n    items = {};\n    constructor(\n    // A name for the dictionary, used for locking.\n    name, \n    // How long the item will remain in the dictionary, in milliseconds.\n    expirationInMilliseconds) {\n        this.lockKey = `ExpirableDictionary:${name}`;\n        this.expirationInMilliseconds = expirationInMilliseconds;\n    }\n    // Tries to fetch an item by its key from the dictionary, or it will call the value factory to add it in.\n    getOrAdd(key, valueFactory) {\n        const item = this.items[key];\n        if (item !== undefined) {\n            return Promise.resolve(item);\n        }\n        return new Promise((resolve, reject) => {\n            navigator.locks\n                .request(`${this.lockKey}:${key}`, async () => {\n                // It's possible the item was added since we requested the lock, check again.\n                const item = this.items[key];\n                if (item !== undefined) {\n                    resolve(item);\n                    return;\n                }\n                try {\n                    const value = (this.items[key] = await valueFactory());\n                    setTimeout(() => this.evict(key), this.expirationInMilliseconds);\n                    resolve(value);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            })\n                .catch(reject);\n        });\n    }\n    evict(key) {\n        delete this.items[key];\n    }\n}\nexport default ExpirableDictionary;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { getGamePassSaleCount } from '../../services/game-passes';\nimport { getTranslationResource } from '../../services/localization';\nimport { getToggleSettingValue } from '../../services/settings';\nimport { createStat } from '../item-details/stats';\nimport { gamePassId, isOwnCreatedItem } from './details';\nif (isOwnCreatedItem) {\n    getToggleSettingValue('itemSalesCounter')\n        .then((enabled) => {\n        if (!enabled) {\n            return;\n        }\n        getGamePassSaleCount(gamePassId)\n            .then(async (saleCount) => {\n            if (isNaN(saleCount)) {\n                return;\n            }\n            try {\n                const salesLabel = await getTranslationResource('CreatorDashboard.Creations', 'Heading.Sales');\n                createStat(salesLabel, saleCount.toLocaleString());\n            }\n            catch (e) {\n                console.error('Failed to render sales label', e);\n            }\n        })\n            .catch((err) => {\n            console.error('Failed to fetch sale count', err);\n        });\n    })\n        .catch((err) => {\n        console.warn('Failed to check if sale counter setting was enabled.', err);\n    });\n}\nexport { createStat };\n"],"names":[],"sourceRoot":""}