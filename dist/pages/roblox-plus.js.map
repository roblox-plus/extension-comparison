{"version":3,"file":"./pages/roblox-plus.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://roblox-plus/./libs/extension-messaging/dist/constants.js","webpack://roblox-plus/./libs/extension-messaging/dist/index.js","webpack://roblox-plus/./libs/extension-messaging/dist/tabs.js","webpack://roblox-plus/./libs/extension-utils/dist/constants/index.js","webpack://roblox-plus/./libs/extension-utils/dist/enums/loading-state.js","webpack://roblox-plus/./libs/extension-utils/dist/index.js","webpack://roblox-plus/./libs/extension-utils/dist/utils/wait.js","webpack://roblox-plus/./libs/roblox/dist/enums/asset-type.js","webpack://roblox-plus/./libs/roblox/dist/enums/presence-type.js","webpack://roblox-plus/./libs/roblox/dist/enums/thumbnail-state.js","webpack://roblox-plus/./libs/roblox/dist/enums/thumbnail-type.js","webpack://roblox-plus/./libs/roblox/dist/enums/trade-status-type.js","webpack://roblox-plus/./libs/roblox/dist/index.js","webpack://roblox-plus/./libs/roblox/dist/utils/linkify.js","webpack://roblox-plus/./src/js/pages/roblox-plus/user-info/index.ts","webpack://roblox-plus/./src/js/pages/roblox-plus/user-info/load.ts","webpack://roblox-plus/./src/js/pages/roblox-plus/user-info/populate.ts","webpack://roblox-plus/./src/js/services/groups/get-creator-groups.ts","webpack://roblox-plus/./src/js/services/groups/get-user-groups.ts","webpack://roblox-plus/./src/js/services/groups/get-user-primary-group.ts","webpack://roblox-plus/./src/js/services/groups/index.ts","webpack://roblox-plus/./src/js/services/premium/getPremiumExpirationDate.ts","webpack://roblox-plus/./src/js/services/premium/index.ts","webpack://roblox-plus/./src/js/services/thumbnails/batchProcessor.ts","webpack://roblox-plus/./src/js/services/thumbnails/index.ts","webpack://roblox-plus/./src/js/services/users/get-user-by-id.ts","webpack://roblox-plus/./src/js/services/users/get-user-by-name.ts","webpack://roblox-plus/./src/js/services/users/getAuthenticatedUser.ts","webpack://roblox-plus/./src/js/services/users/index.ts","webpack://roblox-plus/./src/js/utils/expireableDictionary.ts","webpack://roblox-plus/./src/js/utils/xsrfFetch.ts","webpack://roblox-plus/./node_modules/@tix-factory/batch/dist/batch/index.js","webpack://roblox-plus/./node_modules/@tix-factory/batch/dist/events/errorEvent.js","webpack://roblox-plus/./node_modules/@tix-factory/batch/dist/events/itemErrorEvent.js","webpack://roblox-plus/./node_modules/@tix-factory/batch/dist/index.js","webpack://roblox-plus/./node_modules/@tix-factory/batch/dist/promise-queue/index.js","webpack://roblox-plus/webpack/bootstrap","webpack://roblox-plus/webpack/runtime/define property getters","webpack://roblox-plus/webpack/runtime/hasOwnProperty shorthand","webpack://roblox-plus/webpack/runtime/make namespace object","webpack://roblox-plus/./src/js/pages/roblox-plus/index.ts"],"sourcesContent":["// An identifier that tells us which version of the messaging service we're using,\n// to ensure we don't try to process a message not intended for us.\nconst version = 2.5;\nexport { version };\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { isBackgroundPage } from '@tix-factory/extension-utils';\nimport { version } from './constants';\n// All the listeners, set in the background page.\nconst listeners = {};\n// Keep track of all the listeners that accept external calls.\nconst externalListeners = {};\nconst externalResponseHandlers = {};\n// Send a message to a destination, and get back the result.\nconst sendMessage = (destination, message, external) => __awaiter(void 0, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {\n        var _a;\n        const serializedMessage = JSON.stringify(message);\n        if (isBackgroundPage) {\n            // Message is from the background page, to the background page.\n            try {\n                if (listeners[destination]) {\n                    const message = JSON.parse(serializedMessage);\n                    const result = yield listeners[destination](message);\n                    console.debug(`Local listener response for '${destination}':`, result, message);\n                    const data = result.data === undefined ? undefined : JSON.parse(result.data);\n                    if (result.success) {\n                        resolve(data);\n                    }\n                    else {\n                        reject(data);\n                    }\n                }\n                else {\n                    reject(`No message listener: ${destination}`);\n                }\n            }\n            catch (e) {\n                reject(e);\n            }\n        }\n        else if (chrome === null || chrome === void 0 ? void 0 : chrome.runtime) {\n            // Message is being sent from the content script\n            const outboundMessage = JSON.stringify({\n                version,\n                destination,\n                external,\n                message: serializedMessage,\n            });\n            console.debug(`Sending message to '${destination}'`, serializedMessage);\n            chrome.runtime.sendMessage(outboundMessage, (result) => {\n                if (result === undefined) {\n                    reject(`Unexpected message result (undefined), suggests no listener in background page.\\n\\tDestination: ${destination}`);\n                    return;\n                }\n                const data = result.data === undefined ? undefined : JSON.parse(result.data);\n                if (result.success) {\n                    resolve(data);\n                }\n                else {\n                    reject(data);\n                }\n            });\n        }\n        else if ((_a = document.body) === null || _a === void 0 ? void 0 : _a.dataset.extensionId) {\n            // Message is being sent by the native browser tab.\n            const messageId = crypto.randomUUID();\n            const timeout = setTimeout(() => {\n                if (externalResponseHandlers[messageId]) {\n                    delete externalResponseHandlers[messageId];\n                    reject(`Message timed out trying to contact extension`);\n                }\n            }, 15 * 1000);\n            externalResponseHandlers[messageId] = {\n                resolve: (result) => {\n                    clearTimeout(timeout);\n                    delete externalResponseHandlers[messageId];\n                    resolve(result);\n                },\n                reject: (error) => {\n                    clearTimeout(timeout);\n                    delete externalResponseHandlers[messageId];\n                    reject(error);\n                },\n            };\n            window.postMessage({\n                version,\n                extensionId: document.body.dataset.extensionId,\n                destination,\n                message,\n                messageId,\n            });\n        }\n        else {\n            reject(`Could not find a way to transport the message to the extension.`);\n        }\n    }));\n});\n// Listen for messages at a specific destination.\nconst addListener = (destination, listener, options = {\n    levelOfParallelism: -1,\n}) => {\n    if (listeners[destination]) {\n        throw new Error(`${destination} already has message listener attached`);\n    }\n    const processMessage = (message) => __awaiter(void 0, void 0, void 0, function* () {\n        try {\n            console.debug(`Processing message for '${destination}'`, message);\n            const result = yield listener(message);\n            const response = {\n                success: true,\n                data: JSON.stringify(result),\n            };\n            console.debug(`Successful message result from '${destination}':`, response, message);\n            return response;\n        }\n        catch (err) {\n            const response = {\n                success: false,\n                data: JSON.stringify(err),\n            };\n            console.debug(`Failed message result from '${destination}':`, response, message, err);\n            return response;\n        }\n    });\n    listeners[destination] = (message) => {\n        if (options.levelOfParallelism !== 1) {\n            return processMessage(message);\n        }\n        return new Promise((resolve, reject) => {\n            // https://stackoverflow.com/a/73482349/1663648\n            navigator.locks\n                .request(`messageService:${destination}`, () => __awaiter(void 0, void 0, void 0, function* () {\n                try {\n                    const result = yield processMessage(message);\n                    resolve(result);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            }))\n                .catch(reject);\n        });\n    };\n    if (options.allowExternalConnections) {\n        externalListeners[destination] = true;\n    }\n};\n// If we're currently in the background page, listen for messages.\nif (isBackgroundPage) {\n    chrome.runtime.onMessage.addListener((rawMessage, sender, sendResponse) => {\n        if (typeof rawMessage !== 'string') {\n            // Not for us.\n            return;\n        }\n        const fullMessage = JSON.parse(rawMessage);\n        if (fullMessage.version !== version ||\n            !fullMessage.destination ||\n            !fullMessage.message) {\n            // Not for us.\n            return;\n        }\n        if (fullMessage.external && !externalListeners[fullMessage.destination]) {\n            sendResponse({\n                success: false,\n                data: JSON.stringify('Listener does not accept external callers.'),\n            });\n            return;\n        }\n        const listener = listeners[fullMessage.destination];\n        if (!listener) {\n            sendResponse({\n                success: false,\n                data: JSON.stringify(`Could not route message to destination: ${fullMessage.destination}`),\n            });\n            return;\n        }\n        const message = JSON.parse(fullMessage.message);\n        listener(message)\n            .then(sendResponse)\n            .catch((err) => {\n            console.error('Listener is never expected to throw.', err, rawMessage, fullMessage);\n            sendResponse({\n                success: false,\n                data: JSON.stringify('Listener threw unhandled exception (see background page for error).'),\n            });\n        });\n        // Required for asynchronous callbacks\n        // https://stackoverflow.com/a/20077854/1663648\n        return true;\n    });\n}\nelse if (chrome === null || chrome === void 0 ? void 0 : chrome.runtime) {\n    console.debug(`Not attaching listener for messages, because we're not in the background.`);\n    if (!window.messageServiceConnection) {\n        const port = (window.messageServiceConnection = chrome.runtime.connect(chrome.runtime.id, {\n            name: 'messageService',\n        }));\n        port.onMessage.addListener((rawMessage) => {\n            if (typeof rawMessage !== 'string') {\n                // Not for us.\n                return;\n            }\n            const fullMessage = JSON.parse(rawMessage);\n            if (fullMessage.version !== version ||\n                !fullMessage.destination ||\n                !fullMessage.message) {\n                // Not for us.\n                return;\n            }\n            const listener = listeners[fullMessage.destination];\n            if (!listener) {\n                // No listener in this tab for this message.\n                return;\n            }\n            // We don't really have a way to communicate the response back to the service worker.\n            // So we just... do nothing with it.\n            const message = JSON.parse(fullMessage.message);\n            listener(message).catch((err) => {\n                console.error('Unhandled error processing message in tab', fullMessage, err);\n            });\n        });\n    }\n    // chrome.runtime is available, and we got a message from the window\n    // this could be a tab trying to get information from the extension\n    window.addEventListener('message', (messageEvent) => __awaiter(void 0, void 0, void 0, function* () {\n        const { extensionId, messageId, destination, message } = messageEvent.data;\n        if (extensionId !== chrome.runtime.id ||\n            !messageId ||\n            !destination ||\n            !message) {\n            // They didn't want to contact us.\n            // Or if they did, they didn't have the required fields.\n            return;\n        }\n        if (messageEvent.data.version !== version) {\n            // They did want to contact us, but there was a version mismatch.\n            // We can't handle this message.\n            window.postMessage({\n                extensionId,\n                messageId,\n                success: false,\n                data: `Extension message receiver is incompatible with message sender`,\n            });\n            return;\n        }\n        console.debug('Received message for', destination, message);\n        try {\n            const response = yield sendMessage(destination, message, true);\n            // Success! Now go tell the client they got everything they wanted.\n            window.postMessage({\n                extensionId,\n                messageId,\n                success: true,\n                data: response,\n            });\n        }\n        catch (e) {\n            console.debug('Failed to send message to', destination, e);\n            // :coffin:\n            window.postMessage({\n                extensionId,\n                messageId,\n                success: false,\n                data: e,\n            });\n        }\n    }));\n}\nelse {\n    // Not a background page, and not a content script.\n    // This could be a page where we want to listen for calls from the tab.\n    window.addEventListener('message', (messageEvent) => {\n        const { extensionId, messageId, success, data } = messageEvent.data;\n        if (extensionId !== document.body.dataset.extensionId ||\n            !messageId ||\n            typeof success !== 'boolean') {\n            // Not for us.\n            return;\n        }\n        // Check to see if we have a handler waiting for this message response...\n        const responseHandler = externalResponseHandlers[messageId];\n        if (!responseHandler) {\n            console.warn('We got a response back for a message we no longer have a handler for.', extensionId, messageId, success, data);\n            return;\n        }\n        // Yay! Tell the krustomer we have their data, from the extension.\n        console.debug('We received a response for', messageId, success, data);\n        if (success) {\n            responseHandler.resolve(data);\n        }\n        else {\n            responseHandler.reject(data);\n        }\n    });\n}\nexport { getWorkerTab, sendMessageToTab } from './tabs';\nexport { sendMessage, addListener };\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { isBackgroundPage } from '@tix-factory/extension-utils';\nimport { version } from './constants';\n// All the tabs actively connected to the message service.\nconst tabs = {};\n// Sends a message to a tab.\nconst sendMessageToTab = (destination, message, tab) => __awaiter(void 0, void 0, void 0, function* () {\n    const serializedMessage = JSON.stringify(message);\n    const outboundMessage = JSON.stringify({\n        version,\n        destination,\n        message: serializedMessage,\n    });\n    console.debug(`Sending message to '${destination}' in tab`, serializedMessage, tab);\n    tab.postMessage(outboundMessage);\n});\n// Fetches a tab that we can send a message to, for work processing.\nconst getWorkerTab = () => {\n    const keys = Object.keys(tabs);\n    return keys.length > 0 ? tabs[keys[0]] : undefined;\n};\nif (isBackgroundPage) {\n    chrome.runtime.onConnect.addListener((port) => {\n        const id = crypto.randomUUID();\n        console.debug('Tab connected', id, port);\n        tabs[id] = port;\n        port.onDisconnect.addListener(() => {\n            console.debug('Disconnecting tab', id, port);\n            delete tabs[id];\n        });\n    });\n}\nexport { getWorkerTab, sendMessageToTab };\n","var _a, _b, _c;\nconst manifest = (_a = chrome === null || chrome === void 0 ? void 0 : chrome.runtime) === null || _a === void 0 ? void 0 : _a.getManifest();\nconst isBackgroundPage = ((_b = chrome === null || chrome === void 0 ? void 0 : chrome.runtime) === null || _b === void 0 ? void 0 : _b.getURL(((_c = manifest === null || manifest === void 0 ? void 0 : manifest.background) === null || _c === void 0 ? void 0 : _c.page) || '')) === location.href;\nexport { manifest, isBackgroundPage };\n","// A generic loading state enum.\nvar LoadingState;\n(function (LoadingState) {\n    LoadingState[\"Loading\"] = \"Loading\";\n    LoadingState[\"Success\"] = \"Success\";\n    LoadingState[\"Error\"] = \"Error\";\n})(LoadingState || (LoadingState = {}));\nexport default LoadingState;\n","// Export constants\nexport * from './constants';\n// Export enums\nexport { default as LoadingState } from './enums/loading-state';\n// Export utils\nexport { default as wait } from './utils/wait';\n","const wait = (time) => {\n    return new Promise((resolve, reject) => {\n        setTimeout(resolve, time);\n    });\n};\nexport default wait;\n","var AssetType;\n(function (AssetType) {\n    AssetType[AssetType[\"Image\"] = 1] = \"Image\";\n    AssetType[AssetType[\"TShirt\"] = 2] = \"TShirt\";\n    AssetType[AssetType[\"Audio\"] = 3] = \"Audio\";\n    AssetType[AssetType[\"Mesh\"] = 4] = \"Mesh\";\n    AssetType[AssetType[\"Lua\"] = 5] = \"Lua\";\n    AssetType[AssetType[\"Html\"] = 6] = \"Html\";\n    AssetType[AssetType[\"Text\"] = 7] = \"Text\";\n    AssetType[AssetType[\"Hat\"] = 8] = \"Hat\";\n    AssetType[AssetType[\"Place\"] = 9] = \"Place\";\n    AssetType[AssetType[\"Model\"] = 10] = \"Model\";\n    AssetType[AssetType[\"Shirt\"] = 11] = \"Shirt\";\n    AssetType[AssetType[\"Pants\"] = 12] = \"Pants\";\n    AssetType[AssetType[\"Decal\"] = 13] = \"Decal\";\n    AssetType[AssetType[\"Avatar\"] = 16] = \"Avatar\";\n    AssetType[AssetType[\"Head\"] = 17] = \"Head\";\n    AssetType[AssetType[\"Face\"] = 18] = \"Face\";\n    AssetType[AssetType[\"Gear\"] = 19] = \"Gear\";\n    AssetType[AssetType[\"Badge\"] = 21] = \"Badge\";\n    AssetType[AssetType[\"GroupEmblem\"] = 22] = \"GroupEmblem\";\n    AssetType[AssetType[\"Animation\"] = 24] = \"Animation\";\n    AssetType[AssetType[\"Arms\"] = 25] = \"Arms\";\n    AssetType[AssetType[\"Legs\"] = 26] = \"Legs\";\n    AssetType[AssetType[\"Torso\"] = 27] = \"Torso\";\n    AssetType[AssetType[\"RightArm\"] = 28] = \"RightArm\";\n    AssetType[AssetType[\"LeftArm\"] = 29] = \"LeftArm\";\n    AssetType[AssetType[\"LeftLeg\"] = 30] = \"LeftLeg\";\n    AssetType[AssetType[\"RightLeg\"] = 31] = \"RightLeg\";\n    AssetType[AssetType[\"Package\"] = 32] = \"Package\";\n    AssetType[AssetType[\"YouTubeVideo\"] = 33] = \"YouTubeVideo\";\n    AssetType[AssetType[\"GamePass\"] = 34] = \"GamePass\";\n    AssetType[AssetType[\"App\"] = 35] = \"App\";\n    AssetType[AssetType[\"Code\"] = 37] = \"Code\";\n    AssetType[AssetType[\"Plugin\"] = 38] = \"Plugin\";\n    AssetType[AssetType[\"SolidModel\"] = 39] = \"SolidModel\";\n    AssetType[AssetType[\"MeshPart\"] = 40] = \"MeshPart\";\n    AssetType[AssetType[\"HairAccessory\"] = 41] = \"HairAccessory\";\n    AssetType[AssetType[\"FaceAccessory\"] = 42] = \"FaceAccessory\";\n    AssetType[AssetType[\"NeckAccessory\"] = 43] = \"NeckAccessory\";\n    AssetType[AssetType[\"ShoulderAccessory\"] = 44] = \"ShoulderAccessory\";\n    AssetType[AssetType[\"FrontAccessory\"] = 45] = \"FrontAccessory\";\n    AssetType[AssetType[\"BackAccessory\"] = 46] = \"BackAccessory\";\n    AssetType[AssetType[\"WaistAccessory\"] = 47] = \"WaistAccessory\";\n    AssetType[AssetType[\"ClimbAnimation\"] = 48] = \"ClimbAnimation\";\n    AssetType[AssetType[\"DeathAnimation\"] = 49] = \"DeathAnimation\";\n    AssetType[AssetType[\"FallAnimation\"] = 50] = \"FallAnimation\";\n    AssetType[AssetType[\"IdleAnimation\"] = 51] = \"IdleAnimation\";\n    AssetType[AssetType[\"JumpAnimation\"] = 52] = \"JumpAnimation\";\n    AssetType[AssetType[\"RunAnimation\"] = 53] = \"RunAnimation\";\n    AssetType[AssetType[\"SwimAnimation\"] = 54] = \"SwimAnimation\";\n    AssetType[AssetType[\"WalkAnimation\"] = 55] = \"WalkAnimation\";\n    AssetType[AssetType[\"PoseAnimation\"] = 56] = \"PoseAnimation\";\n    AssetType[AssetType[\"EarAccessory\"] = 57] = \"EarAccessory\";\n    AssetType[AssetType[\"EyeAccessory\"] = 58] = \"EyeAccessory\";\n    AssetType[AssetType[\"LocalizationTableManifest\"] = 59] = \"LocalizationTableManifest\";\n    AssetType[AssetType[\"LocalizationTableTranslation\"] = 60] = \"LocalizationTableTranslation\";\n    AssetType[AssetType[\"Emote\"] = 61] = \"Emote\";\n    AssetType[AssetType[\"Video\"] = 62] = \"Video\";\n    AssetType[AssetType[\"TexturePack\"] = 63] = \"TexturePack\";\n    AssetType[AssetType[\"TShirtAccessory\"] = 64] = \"TShirtAccessory\";\n    AssetType[AssetType[\"ShirtAccessory\"] = 65] = \"ShirtAccessory\";\n    AssetType[AssetType[\"PantsAccessory\"] = 66] = \"PantsAccessory\";\n    AssetType[AssetType[\"JacketAccessory\"] = 67] = \"JacketAccessory\";\n    AssetType[AssetType[\"SweaterAccessory\"] = 68] = \"SweaterAccessory\";\n    AssetType[AssetType[\"ShortsAccessory\"] = 69] = \"ShortsAccessory\";\n    AssetType[AssetType[\"LeftShoeAccessory\"] = 70] = \"LeftShoeAccessory\";\n    AssetType[AssetType[\"RightShoeAccessory\"] = 71] = \"RightShoeAccessory\";\n    AssetType[AssetType[\"DressSkirtAccessory\"] = 72] = \"DressSkirtAccessory\";\n    AssetType[AssetType[\"FontFamily\"] = 73] = \"FontFamily\";\n    AssetType[AssetType[\"FontFace\"] = 74] = \"FontFace\";\n    AssetType[AssetType[\"MeshHiddenSurfaceRemoval\"] = 75] = \"MeshHiddenSurfaceRemoval\";\n    AssetType[AssetType[\"EyebrowAccessory\"] = 76] = \"EyebrowAccessory\";\n    AssetType[AssetType[\"EyelashAccessory\"] = 77] = \"EyelashAccessory\";\n    AssetType[AssetType[\"MoodAnimation\"] = 78] = \"MoodAnimation\";\n    AssetType[AssetType[\"DynamicHead\"] = 79] = \"DynamicHead\";\n})(AssetType || (AssetType = {}));\nexport default AssetType;\n","// The types of user presence.\nvar PresenceType;\n(function (PresenceType) {\n    // The user is offline.\n    PresenceType[\"Offline\"] = \"Offline\";\n    // The user is online.\n    PresenceType[\"Online\"] = \"Online\";\n    // The user is currently in an experience.\n    PresenceType[\"Experience\"] = \"Experience\";\n    // The user is currently in Roblox Studio.\n    PresenceType[\"Studio\"] = \"Studio\";\n})(PresenceType || (PresenceType = {}));\nexport default PresenceType;\n","// Possible states for a thumbnail to be in.\nvar ThumbnailState;\n(function (ThumbnailState) {\n    // The thumbnail had an unexpected error trying to load.\n    ThumbnailState[\"Error\"] = \"Error\";\n    // The thumbnailed loaded successfully.\n    ThumbnailState[\"Completed\"] = \"Completed\";\n    // The thumbnail is currently in review.\n    ThumbnailState[\"InReview\"] = \"InReview\";\n    // The thumbnail is pending, and should be retried.\n    ThumbnailState[\"Pending\"] = \"Pending\";\n    // The thumbnail is blocked.\n    ThumbnailState[\"Blocked\"] = \"Blocked\";\n    // The thumbnail is temporarily unavailable.\n    ThumbnailState[\"TemporarilyUnavailable\"] = \"TemporarilyUnavailable\";\n})(ThumbnailState || (ThumbnailState = {}));\nexport default ThumbnailState;\n","// The types of thumbnails that can be requested.\nvar ThumbnailType;\n(function (ThumbnailType) {\n    // An avatar head shot thumbnail.\n    ThumbnailType[\"AvatarHeadShot\"] = \"AvatarHeadShot\";\n    // The thumbnail for an asset.\n    ThumbnailType[\"Asset\"] = \"Asset\";\n    // The icon for a group.\n    ThumbnailType[\"GroupIcon\"] = \"GroupIcon\";\n    // The icon for a game pass.\n    ThumbnailType[\"GamePass\"] = \"GamePass\";\n    // The icon for a developer product.\n    ThumbnailType[\"DeveloperProduct\"] = \"DeveloperProduct\";\n    // The icon for a game.\n    ThumbnailType[\"GameIcon\"] = \"GameIcon\";\n})(ThumbnailType || (ThumbnailType = {}));\nexport default ThumbnailType;\n","var TradeStatusType;\n(function (TradeStatusType) {\n    TradeStatusType[\"Inbound\"] = \"Inbound\";\n    TradeStatusType[\"Outbound\"] = \"Outbound\";\n    TradeStatusType[\"Completed\"] = \"Completed\";\n    TradeStatusType[\"Inactive\"] = \"Inactive\";\n})(TradeStatusType || (TradeStatusType = {}));\nexport default TradeStatusType;\n","// Export enums\nexport { default as AssetType } from './enums/asset-type';\nexport { default as PresenceType } from './enums/presence-type';\nexport { default as ThumbnailState } from './enums/thumbnail-state';\nexport { default as ThumbnailType } from './enums/thumbnail-type';\nexport { default as TradeStatusType } from './enums/trade-status-type';\n// Export utils\nexport * from './utils/linkify';\n","const getSEOLink = (id, name, path) => {\n    if (!name) {\n        name = 'redirect';\n    }\n    else {\n        name =\n            name\n                .replace(/'/g, '')\n                .replace(/\\W+/g, '-')\n                .replace(/^-+/, '')\n                .replace(/-+$/, '') || 'redirect';\n    }\n    return new URL(`https://www.roblox.com/${path}/${id}/${name}`);\n};\nconst getGamePassLink = (gamePassId, gamePassName) => {\n    return getSEOLink(gamePassId, gamePassName, 'game-pass');\n};\nconst getCatalogLink = (assetId, assetName) => {\n    return getSEOLink(assetId, assetName, 'catalog');\n};\nconst getLibraryLink = (assetId, assetName) => {\n    return getSEOLink(assetId, assetName, 'library');\n};\nconst getPlaceLink = (placeId, placeName) => {\n    return getSEOLink(placeId, placeName, 'games');\n};\nconst getUserProfileLink = (userId) => {\n    return getSEOLink(userId, 'profile', 'users');\n};\nconst getIdFromUrl = (url) => {\n    const match = url.pathname.match(/^\\/(badges|games|game-pass|groups|catalog|library|users)\\/(\\d+)\\/?/i) || [];\n    // Returns NaN if the URL doesn't match.\n    return Number(match[2]);\n};\nexport { getGamePassLink, getCatalogLink, getLibraryLink, getPlaceLink, getUserProfileLink, getIdFromUrl, };\n","import load from './load';\nimport populate from './populate';\nexport { load, populate };\n","import { ThumbnailState } from 'roblox';\nimport { getCreatorGroups, getUserGroups, getUserPrimaryGroup, } from '../../../services/groups';\nimport { getPremiumExpirationDate } from '../../../services/premium';\nimport { getAvatarHeadshotThumbnail, getGroupIcon, } from '../../../services/thumbnails';\nimport { getAuthenticatedUser } from '../../../services/users';\n// Loads a detailed group object.\nconst loadDetailedGroup = async (group) => {\n    const detailedGroup = Object.assign({\n        thumbnail: {\n            imageUrl: '',\n            state: ThumbnailState.Error,\n        },\n    }, group);\n    try {\n        detailedGroup.thumbnail = await getGroupIcon(group.id);\n    }\n    catch (e) {\n        console.warn('Failed to load thumbnail for group', group, e);\n    }\n    return detailedGroup;\n};\n// Loads all the information about the user that should be injected into the page.\nconst load = async () => {\n    const user = await getAuthenticatedUser();\n    if (!user) {\n        return null;\n    }\n    const userInfo = {\n        user,\n        premiumExpiration: undefined,\n        thumbnail: {\n            imageUrl: '',\n            state: ThumbnailState.Error,\n        },\n        groups: {\n            list: [],\n            creatorList: [],\n            primary: null,\n        },\n    };\n    try {\n        userInfo.thumbnail = await getAvatarHeadshotThumbnail(user.id);\n    }\n    catch (err) {\n        console.warn('Failed to load user thumbnail', user, err);\n    }\n    try {\n        userInfo.premiumExpiration = await getPremiumExpirationDate(user.id);\n    }\n    catch (err) {\n        console.warn('Failed to load user premium status', user, err);\n    }\n    try {\n        const groupList = await getUserGroups(user.id);\n        userInfo.groups.list = await Promise.all(groupList.map(loadDetailedGroup));\n        const primaryGroup = await getUserPrimaryGroup(user.id);\n        if (primaryGroup) {\n            userInfo.groups.primary = await loadDetailedGroup(primaryGroup);\n        }\n        const creatorGroups = await getCreatorGroups(user.id);\n        userInfo.groups.creatorList = await Promise.all(creatorGroups.map(loadDetailedGroup));\n    }\n    catch (err) {\n        console.warn('Failed to load groups for user', user, err);\n    }\n    return userInfo;\n};\nexport default load;\n","import { ThumbnailState } from 'roblox';\n// Creates an individual element containing the group information.\nconst createGroupMeta = (group, creatorGroupIds, primaryGroupId) => {\n    const groupMeta = document.createElement('meta');\n    groupMeta.dataset.groupId = `${group.id}`;\n    groupMeta.dataset.groupName = group.name;\n    groupMeta.dataset.groupManager = `${creatorGroupIds.includes(group.id)}`;\n    groupMeta.dataset.groupPrimary = `${primaryGroupId === group.id}`;\n    if (group.thumbnail.state === ThumbnailState.Completed) {\n        groupMeta.dataset.groupIcon = group.thumbnail.imageUrl;\n    }\n    return groupMeta;\n};\n// Creates the container which is popualted with all the groups.\nconst createGroupsContainer = (userInfo) => {\n    const groupsContainer = document.createElement('div');\n    groupsContainer.setAttribute('id', 'rplus-groups');\n    groupsContainer.style.display = 'hidden';\n    const creatorGroupIds = userInfo.groups.creatorList.map((g) => g.id);\n    userInfo.groups.list.forEach((group) => {\n        groupsContainer.append(createGroupMeta(group, creatorGroupIds, userInfo.groups.primary?.id));\n    });\n    return groupsContainer;\n};\n// Populate all the information into the DOM.\nconst populate = (userInfo) => {\n    const data = {};\n    try {\n        if (!userInfo) {\n            data.userId = '0';\n            data.userThumbnailState = ThumbnailState.Blocked;\n            return;\n        }\n        // Populate group information\n        document.body.append(createGroupsContainer(userInfo));\n        // Inject in premium status\n        if (userInfo.premiumExpiration === null) {\n            data.userPremiumExpiration = 'null';\n        }\n        else if (userInfo.premiumExpiration) {\n            data.userPremiumExpiration = userInfo.premiumExpiration.toISOString();\n        }\n        // Inject in user data\n        data.userId = `${userInfo.user.id}`;\n        data.userName = userInfo.user.name;\n        data.userDisplayName = userInfo.user.displayName;\n        // HACK: Inject in thumbnail last, the app waits for the thumbnail state to be loaded in before doing anything.\n        data.userThumbnailImage = userInfo.thumbnail.imageUrl;\n        data.userThumbnailState = userInfo.thumbnail.state;\n    }\n    catch (err) {\n        console.error('Failed to load page data from extension', err);\n    }\n    finally {\n        Object.keys(data).forEach((key) => {\n            document.body.dataset[key] = data[key];\n        });\n    }\n};\nexport default populate;\n","import { addListener, sendMessage } from '@tix-factory/extension-messaging';\nimport ExpirableDictionary from '../../utils/expireableDictionary';\nconst messageDestination = 'groupsService.getCreatorGroups';\nconst cache = new ExpirableDictionary(messageDestination, 30 * 1000);\n// Fetches the groups the user has access privileged roles in.\nconst getCreatorGroups = (userId) => {\n    return sendMessage(messageDestination, { userId });\n};\n// Loads the groups the user has access privileged roles in.\nconst loadAuthenticatedUserCreatorGroups = async () => {\n    const response = await fetch(`https://develop.roblox.com/v1/user/groups/canmanage`);\n    if (response.status === 401) {\n        throw 'User is unauthenticated';\n    }\n    else if (!response.ok) {\n        throw 'Failed to load creation groups for the authenticated user';\n    }\n    const result = await response.json();\n    return result.data.map((g) => {\n        return {\n            id: g.id,\n            name: g.name,\n        };\n    });\n};\n// Listen for messages sent to the service worker.\naddListener(messageDestination, (message) => {\n    // Check the cache\n    return cache.getOrAdd(`${message.userId}`, () => \n    // Queue up the fetch request, when not in the cache\n    loadAuthenticatedUserCreatorGroups());\n}, {\n    levelOfParallelism: 1,\n    allowExternalConnections: true,\n});\nexport default getCreatorGroups;\n","import { addListener, sendMessage } from '@tix-factory/extension-messaging';\nimport ExpirableDictionary from '../../utils/expireableDictionary';\nconst messageDestination = 'groupsService.getUserGroups';\nconst cache = new ExpirableDictionary(messageDestination, 30 * 1000);\n// Fetches the groups the user is a member of.\nconst getUserGroups = (userId) => {\n    return sendMessage(messageDestination, { userId });\n};\n// Loads the groups the user is a member of.\nconst loadUserGroups = async (userId) => {\n    const response = await fetch(`https://groups.roblox.com/v1/users/${userId}/groups/roles`);\n    if (!response.ok) {\n        throw 'Failed to load groups the user is a member of';\n    }\n    const result = await response.json();\n    return result.data.map((g) => {\n        return {\n            id: g.group.id,\n            name: g.group.name,\n        };\n    });\n};\n// Listen for messages sent to the service worker.\naddListener(messageDestination, (message) => {\n    // Check the cache\n    return cache.getOrAdd(`${message.userId}`, () => \n    // Queue up the fetch request, when not in the cache\n    loadUserGroups(message.userId));\n}, {\n    levelOfParallelism: 1,\n    allowExternalConnections: true,\n});\nexport default getUserGroups;\n","import { addListener, sendMessage } from '@tix-factory/extension-messaging';\nimport ExpirableDictionary from '../../utils/expireableDictionary';\nconst messageDestination = 'groupsService.getUserPrimaryGroup';\nconst cache = new ExpirableDictionary(messageDestination, 30 * 1000);\n// Fetches the groups the user is a member of.\nconst getUserPrimaryGroup = (userId) => {\n    return sendMessage(messageDestination, { userId });\n};\n// Loads the groups the user is a member of.\nconst loadUserPrimaryGroup = async (userId) => {\n    const response = await fetch(`https://groups.roblox.com/v1/users/${userId}/groups/primary/role`);\n    if (!response.ok) {\n        throw 'Failed to load primary group for the user';\n    }\n    const result = await response.json();\n    if (!result || !result.group) {\n        return null;\n    }\n    return {\n        id: result.group.id,\n        name: result.group.name,\n    };\n};\n// Listen for messages sent to the service worker.\naddListener(messageDestination, (message) => {\n    // Check the cache\n    return cache.getOrAdd(`${message.userId}`, () => \n    // Queue up the fetch request, when not in the cache\n    loadUserPrimaryGroup(message.userId));\n}, {\n    levelOfParallelism: 1,\n    allowExternalConnections: true,\n});\nexport default getUserPrimaryGroup;\n","import getCreatorGroups from './get-creator-groups';\nimport getUserGroups from './get-user-groups';\nimport getUserPrimaryGroup from './get-user-primary-group';\nglobalThis.groupsService = { getCreatorGroups, getUserGroups, getUserPrimaryGroup };\nexport { getCreatorGroups, getUserGroups, getUserPrimaryGroup };\n","import { addListener, sendMessage } from '@tix-factory/extension-messaging';\nimport ExpirableDictionary from '../../utils/expireableDictionary';\nconst messageDestination = 'premiumService.getPremiumExpirationDate';\nconst definitelyPremium = {};\nconst cache = new ExpirableDictionary(messageDestination, 60 * 1000);\n// Check whether or not a user has a Roblox+ Premium subscription.\nconst getPremiumExpirationDate = async (userId) => {\n    const expiration = await sendMessage(messageDestination, {\n        userId,\n    });\n    if (!expiration) {\n        return expiration;\n    }\n    return new Date(expiration);\n};\nconst getPrivateServerExpiration = async (id) => {\n    const response = await fetch(`https://games.roblox.com/v1/vip-servers/${id}`);\n    if (!response.ok) {\n        console.warn('Failed to load private server details', id, response);\n        return null;\n    }\n    const result = await response.json();\n    if (result.subscription?.expired === false) {\n        // If it's not expired, return the expiration date.\n        return result.subscription.expirationDate;\n    }\n    return null;\n};\n// Check if the user has a private server with the Roblox+ hub.\nconst checkPrivateServerExpirations = async (userId) => {\n    try {\n        const response = await fetch(`https://games.roblox.com/v1/games/258257446/private-servers`);\n        if (!response.ok) {\n            console.warn('Failed to load private servers', userId, response);\n            return null;\n        }\n        const result = await response.json();\n        for (let i = 0; i < result.data.length; i++) {\n            const privateServer = result.data[i];\n            if (privateServer.owner?.id !== userId) {\n                continue;\n            }\n            try {\n                const expirationDate = await getPrivateServerExpiration(privateServer.vipServerId);\n                if (expirationDate) {\n                    // We found a private server we paid for, we're done!\n                    return expirationDate;\n                }\n            }\n            catch (err) {\n                console.warn('Failed to check if private server was active', privateServer, err);\n            }\n        }\n        return null;\n    }\n    catch (err) {\n        console.warn('Failed to check private servers', userId, err);\n        return null;\n    }\n};\n// Fetch whether or not a user has a Roblox+ Premium subscription.\nconst loadPremiumMembership = async (userId) => {\n    if (definitelyPremium[userId]) {\n        return definitelyPremium[userId];\n    }\n    const expirationDate = await checkPrivateServerExpirations(userId);\n    if (expirationDate) {\n        return (definitelyPremium[userId] = expirationDate);\n    }\n    const response = await fetch(`https://api.roblox.plus/v1/rpluspremium/${userId}`);\n    if (!response.ok) {\n        throw new Error(`Failed to check premium membership for user (${userId})`);\n    }\n    const result = await response.json();\n    if (result.data) {\n        return (definitelyPremium[userId] = result.data.expiration);\n    }\n    return '';\n};\n// Listen for messages sent to the service worker.\naddListener(messageDestination, (message) => {\n    // Check the cache\n    return cache.getOrAdd(`${message.userId}`, () => \n    // Queue up the fetch request, when not in the cache\n    loadPremiumMembership(message.userId));\n}, {\n    levelOfParallelism: 1,\n    allowExternalConnections: true,\n});\nexport default getPremiumExpirationDate;\n","import { default as getPremiumExpirationDate } from './getPremiumExpirationDate';\nconst isPremiumUser = async (userId) => {\n    const expiration = await getPremiumExpirationDate(userId);\n    if (expiration || expiration === null) {\n        // We have an expiration date, or it's a lifetime subscription.\n        // They are definitely premium.\n        return true;\n    }\n    // No expiration date, no premium.\n    return false;\n};\nglobalThis.premiumService = { isPremiumUser, getPremiumExpirationDate };\nexport { isPremiumUser, getPremiumExpirationDate };\n","import { Batch } from '@tix-factory/batch';\nimport { ThumbnailState } from 'roblox';\nclass ThumbnailBatchProcessor extends Batch {\n    constructor() {\n        super({\n            levelOfParallelism: 1,\n            maxSize: 100,\n            minimumDelay: 1 * 1000,\n            enqueueDeferDelay: 10,\n        });\n    }\n    async process(items) {\n        const response = await fetch('https://thumbnails.roblox.com/v1/batch', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(items.map(({ value }) => {\n                return {\n                    requestId: `${value.type}_${value.targetId}_${value.size}`,\n                    type: value.type,\n                    targetId: value.targetId,\n                    size: value.size,\n                };\n            })),\n        });\n        if (!response.ok) {\n            throw new Error('Failed to load thumbnails');\n        }\n        const result = await response.json();\n        items.forEach((item) => {\n            const thumbnail = result.data.find((t) => t.requestId ===\n                `${item.value.type}_${item.value.targetId}_${item.value.size}`);\n            if (thumbnail) {\n                const thumbnailState = thumbnail.state;\n                item.resolve({\n                    state: thumbnailState,\n                    imageUrl: thumbnailState === ThumbnailState.Completed\n                        ? thumbnail.imageUrl\n                        : '',\n                });\n            }\n            else {\n                item.resolve({\n                    state: ThumbnailState.Error,\n                    imageUrl: '',\n                });\n            }\n        });\n    }\n}\nconst thumbnailBatchProcessor = new ThumbnailBatchProcessor();\nexport default thumbnailBatchProcessor;\n","import { addListener, sendMessage } from '@tix-factory/extension-messaging';\nimport { ThumbnailState, ThumbnailType } from 'roblox';\nimport ExpirableDictionary from '../../utils/expireableDictionary';\nimport batchProcessor from './batchProcessor';\nconst messageDestination = 'thumbnailsService.getThumbnail';\nconst cache = new ExpirableDictionary(messageDestination, 5 * 60 * 1000);\n// Fetches an avatar headshot thumbnail, for the given user ID.\nconst getAvatarHeadshotThumbnail = (userId) => {\n    return sendMessage(messageDestination, {\n        type: ThumbnailType.AvatarHeadShot,\n        targetId: userId,\n    });\n};\n// Fetches an asset thumbnail, for the given asset ID.\nconst getAssetThumbnail = (assetId) => {\n    return sendMessage(messageDestination, {\n        type: ThumbnailType.Asset,\n        targetId: assetId,\n    });\n};\n// Fetches a group icon.\nconst getGroupIcon = (groupId) => {\n    return sendMessage(messageDestination, {\n        type: ThumbnailType.GroupIcon,\n        targetId: groupId,\n    });\n};\n// Fetches a game pass icon.\nconst getGamePassIcon = (gamePassId) => {\n    return sendMessage(messageDestination, {\n        type: ThumbnailType.GamePass,\n        targetId: gamePassId,\n    });\n};\n// Fetches a developer product icon.\nconst getDeveloperProductIcon = (gamePassId) => {\n    return sendMessage(messageDestination, {\n        type: ThumbnailType.DeveloperProduct,\n        targetId: gamePassId,\n    });\n};\n// Fetches a game icon.\nconst getGameIcon = (gamePassId) => {\n    return sendMessage(messageDestination, {\n        type: ThumbnailType.GameIcon,\n        targetId: gamePassId,\n    });\n};\n// Gets the default size for the thumbnail, by type.\nconst getThumbnailSize = (thumbnailType) => {\n    switch (thumbnailType) {\n        case ThumbnailType.GamePass:\n            return '150x150';\n        case ThumbnailType.GameIcon:\n            return '256x256';\n        default:\n            return '420x420';\n    }\n};\n// Listen for messages sent to the service worker.\naddListener(messageDestination, async (message) => {\n    const cacheKey = `${message.type}:${message.targetId}`;\n    // Check the cache\n    const thumbnail = await cache.getOrAdd(cacheKey, () => \n    // Queue up the fetch request, when not in the cache\n    batchProcessor.enqueue({\n        type: message.type,\n        targetId: message.targetId,\n        size: getThumbnailSize(message.type),\n    }));\n    if (thumbnail.state !== ThumbnailState.Completed) {\n        setTimeout(() => {\n            // If the thumbnail isn't complete, evict it from the cache early.\n            cache.evict(cacheKey);\n        }, 30 * 1000);\n    }\n    return thumbnail;\n}, {\n    levelOfParallelism: -1,\n    allowExternalConnections: true,\n});\nglobalThis.thumbnailsService = {\n    getAvatarHeadshotThumbnail,\n    getAssetThumbnail,\n    getGroupIcon,\n    getGamePassIcon,\n    getDeveloperProductIcon,\n    getGameIcon,\n};\nexport { getAvatarHeadshotThumbnail, getAssetThumbnail, getGroupIcon, getGamePassIcon, getDeveloperProductIcon, getGameIcon, };\n","import { Batch } from '@tix-factory/batch';\nimport { addListener, sendMessage } from '@tix-factory/extension-messaging';\nimport ExpirableDictionary from '../../utils/expireableDictionary';\nimport xsrfFetch from '../../utils/xsrfFetch';\nconst messageDestination = 'usersService.getUserById';\nclass UsersBatchProcessor extends Batch {\n    constructor() {\n        super({\n            levelOfParallelism: 1,\n            maxSize: 100,\n            minimumDelay: 1000,\n            enqueueDeferDelay: 10,\n        });\n    }\n    async process(items) {\n        const response = await xsrfFetch(new URL(`https://users.roblox.com/v1/users`), {\n            method: 'POST',\n            body: JSON.stringify({\n                userIds: items.map((i) => i.key),\n                excludeBannedUsers: false,\n            }),\n        });\n        if (!response.ok) {\n            throw new Error('Failed to users by ids');\n        }\n        const result = await response.json();\n        items.forEach((item) => {\n            const user = result.data.find((a) => a.id === item.value);\n            if (user) {\n                item.resolve({\n                    id: user.id,\n                    name: user.name,\n                    displayName: user.displayName,\n                });\n            }\n            else {\n                item.resolve(null);\n            }\n        });\n    }\n    getKey(item) {\n        return item.toString();\n    }\n}\nconst batchProcessor = new UsersBatchProcessor();\nconst cache = new ExpirableDictionary(messageDestination, 2 * 60 * 1000);\n// Fetches the date when a badge was awarded to the specified user.\nconst getUserById = async (id) => {\n    return sendMessage(messageDestination, {\n        id,\n    });\n};\n// Listen for messages sent to the service worker.\naddListener(messageDestination, (message) => {\n    // Check the cache\n    return cache.getOrAdd(batchProcessor.getKey(message.id), () => {\n        // Queue up the fetch request, when not in the cache\n        return batchProcessor.enqueue(message.id);\n    });\n});\nexport default getUserById;\n","import { Batch } from '@tix-factory/batch';\nimport { addListener, sendMessage } from '@tix-factory/extension-messaging';\nimport ExpirableDictionary from '../../utils/expireableDictionary';\nimport xsrfFetch from '../../utils/xsrfFetch';\nconst messageDestination = 'usersService.getUserByName';\nclass UserNamesBatchProcessor extends Batch {\n    constructor() {\n        super({\n            levelOfParallelism: 1,\n            maxSize: 100,\n            minimumDelay: 1000,\n            enqueueDeferDelay: 10,\n        });\n    }\n    async process(items) {\n        const response = await xsrfFetch(new URL(`https://users.roblox.com/v1/usernames/users`), {\n            method: 'POST',\n            body: JSON.stringify({\n                usernames: items.map((i) => i.key),\n                excludeBannedUsers: false,\n            }),\n        });\n        if (!response.ok) {\n            throw new Error('Failed to users by names');\n        }\n        const result = await response.json();\n        items.forEach((item) => {\n            const user = result.data.find((a) => a.requestedUsername === item.key);\n            if (user) {\n                item.resolve({\n                    id: user.id,\n                    name: user.name,\n                    displayName: user.displayName,\n                });\n            }\n            else {\n                item.resolve(null);\n            }\n        });\n    }\n    getKey(item) {\n        return item;\n    }\n}\nconst batchProcessor = new UserNamesBatchProcessor();\nconst cache = new ExpirableDictionary(messageDestination, 2 * 60 * 1000);\n// Fetches the date when a badge was awarded to the specified user.\nconst getUserByName = async (name) => {\n    return sendMessage(messageDestination, {\n        name: name.toLowerCase(),\n    });\n};\n// Listen for messages sent to the service worker.\naddListener(messageDestination, (message) => {\n    // Check the cache\n    return cache.getOrAdd(batchProcessor.getKey(message.name), () => {\n        // Queue up the fetch request, when not in the cache\n        return batchProcessor.enqueue(message.name);\n    });\n});\nexport default getUserByName;\n","import { addListener, sendMessage } from '@tix-factory/extension-messaging';\nconst messageDestination = 'usersService.getAuthenticatedUser';\nconst cacheDuration = 60 * 1000;\nlet authenticatedUser = undefined;\n// Fetches the currently authenticated user.\nconst getAuthenticatedUser = () => {\n    return sendMessage(messageDestination, {});\n};\n// Loads the currently authenticated user.\nconst loadAuthenticatedUser = async () => {\n    if (authenticatedUser !== undefined) {\n        return authenticatedUser;\n    }\n    try {\n        const response = await fetch('https://users.roblox.com/v1/users/authenticated');\n        if (response.status === 401) {\n            return (authenticatedUser = null);\n        }\n        else if (!response.ok) {\n            throw new Error('Failed to load authenticated user');\n        }\n        const result = await response.json();\n        return (authenticatedUser = {\n            id: result.id,\n            name: result.name,\n            displayName: result.displayName,\n        });\n    }\n    finally {\n        setTimeout(() => {\n            authenticatedUser = undefined;\n        }, cacheDuration);\n    }\n};\naddListener(messageDestination, () => loadAuthenticatedUser(), {\n    levelOfParallelism: 1,\n});\nexport default getAuthenticatedUser;\n","import getAuthenticatedUser from './getAuthenticatedUser';\nimport getUserByName from './get-user-by-name';\nimport getUserById from './get-user-by-id';\nglobalThis.usersService = { getAuthenticatedUser, getUserByName, getUserById };\nexport { getAuthenticatedUser, getUserByName, getUserById };\n","// This class can be used to concurrently cache items, or fetch their values.\nclass ExpirableDictionary {\n    lockKey;\n    expirationInMilliseconds;\n    // The items that are in the dictionary.\n    items = {};\n    constructor(\n    // A name for the dictionary, used for locking.\n    name, \n    // How long the item will remain in the dictionary, in milliseconds.\n    expirationInMilliseconds) {\n        this.lockKey = `ExpirableDictionary:${name}`;\n        this.expirationInMilliseconds = expirationInMilliseconds;\n    }\n    // Tries to fetch an item by its key from the dictionary, or it will call the value factory to add it in.\n    getOrAdd(key, valueFactory) {\n        const item = this.items[key];\n        if (item !== undefined) {\n            return Promise.resolve(item);\n        }\n        return new Promise((resolve, reject) => {\n            navigator.locks\n                .request(`${this.lockKey}:${key}`, async () => {\n                // It's possible the item was added since we requested the lock, check again.\n                const item = this.items[key];\n                if (item !== undefined) {\n                    resolve(item);\n                    return;\n                }\n                try {\n                    const value = (this.items[key] = await valueFactory());\n                    setTimeout(() => this.evict(key), this.expirationInMilliseconds);\n                    resolve(value);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            })\n                .catch(reject);\n        });\n    }\n    evict(key) {\n        delete this.items[key];\n    }\n}\nexport default ExpirableDictionary;\n","const headerName = 'X-CSRF-Token';\nlet xsrfToken = '';\n// A fetch request which will attach an X-CSRF-Token in all outbound requests.\nconst xsrfFetch = async (url, requestDetails) => {\n    if (url.hostname.endsWith('.roblox.com')) {\n        if (!requestDetails) {\n            requestDetails = {};\n        }\n        requestDetails.credentials = 'include';\n        if (!requestDetails.headers) {\n            requestDetails.headers = new Headers();\n        }\n        if (requestDetails.headers instanceof Headers) {\n            if (xsrfToken) {\n                requestDetails.headers.set(headerName, xsrfToken);\n            }\n            if (requestDetails.body && !requestDetails.headers.has('Content-Type')) {\n                requestDetails.headers.set('Content-Type', 'application/json');\n            }\n        }\n    }\n    const response = await fetch(url, requestDetails);\n    const token = response.headers.get(headerName);\n    if (response.ok || !token) {\n        return response;\n    }\n    xsrfToken = token;\n    return xsrfFetch(url, requestDetails);\n};\nexport default xsrfFetch;\n","import PromiseQueue from '../promise-queue';\nimport ErrorEvent from '../events/errorEvent';\nimport ItemErrorEvent from '../events/itemErrorEvent';\n// A class for batching and processing multiple single items into a single call.\nclass Batch extends EventTarget {\n    queueMap = {};\n    promiseMap = {};\n    limiter;\n    concurrencyHandler;\n    // All the batch items waiting to be processed.\n    queueArray = [];\n    // The configuration for this batch processor.\n    config;\n    constructor(configuration) {\n        super();\n        this.config = configuration;\n        this.limiter = new PromiseQueue({\n            levelOfParallelism: 1,\n            delayInMilliseconds: configuration.minimumDelay || 0,\n        });\n        this.concurrencyHandler = new PromiseQueue({\n            levelOfParallelism: configuration.levelOfParallelism || Infinity,\n        });\n    }\n    // Enqueues an item into a batch, to be processed.\n    enqueue(item) {\n        return new Promise((resolve, reject) => {\n            const key = this.getKey(item);\n            const promiseMap = this.promiseMap;\n            const queueArray = this.queueArray;\n            const queueMap = this.queueMap;\n            const retryCount = this.config.retryCount || 0;\n            const getRetryDelay = this.getRetryDelay.bind(this);\n            const dispatchEvent = this.dispatchEvent.bind(this);\n            const check = this.check.bind(this);\n            // Step 1: Ensure we have a way to resolve/reject the promise for this item.\n            const mergedPromise = promiseMap[key] || [];\n            if (mergedPromise.length < 0) {\n                this.promiseMap[key] = mergedPromise;\n            }\n            mergedPromise.push({ resolve, reject });\n            // Step 2: Check if we have the batched item created.\n            if (!queueMap[key]) {\n                const remove = (item) => {\n                    // Mark the item as completed, so we know we either resolved or rejected it.\n                    item.completed = true;\n                    for (let i = 0; i < queueArray.length; i++) {\n                        if (queueArray[i].key === key) {\n                            queueArray.splice(i, 1);\n                            break;\n                        }\n                    }\n                    delete promiseMap[key];\n                    delete queueMap[key];\n                };\n                const batchItem = {\n                    key,\n                    value: item,\n                    attempt: 0,\n                    retryAfter: 0,\n                    completed: false,\n                    resolve(result) {\n                        // We're not accepting any new items for this resolution.\n                        remove(this);\n                        // Defer the resolution until after the thread resolves.\n                        setTimeout(() => {\n                            // Process anyone who applied.\n                            while (mergedPromise.length > 0) {\n                                const promise = mergedPromise.shift();\n                                promise?.resolve(result);\n                            }\n                        }, 0);\n                    },\n                    reject(error) {\n                        // Defer the resolution until after the thread resolves.\n                        const retryDelay = this.attempt <= retryCount ? getRetryDelay(this) : undefined;\n                        const retryAfter = retryDelay !== undefined\n                            ? performance.now() + retryDelay\n                            : undefined;\n                        // Emit an event to notify that the item failed to process.\n                        dispatchEvent(new ItemErrorEvent(error, this, retryAfter));\n                        if (retryAfter !== undefined) {\n                            // The item can be retried, we haven't hit the maximum number of attempts yet.\n                            this.retryAfter = retryAfter;\n                            // Ensure the check runs after the retry delay.\n                            setTimeout(check, retryDelay);\n                        }\n                        else {\n                            // Remove the item, and reject anyone waiting on it.\n                            remove(this);\n                            // Defer the resolution until after the thread resolves.\n                            setTimeout(() => {\n                                // Process anyone who applied.\n                                while (mergedPromise.length > 0) {\n                                    const promise = mergedPromise.shift();\n                                    promise?.reject(error);\n                                }\n                            }, 0);\n                        }\n                    },\n                };\n                queueMap[key] = batchItem;\n                queueArray.push(batchItem);\n            }\n            // Attempt to process the queue on the next event loop.\n            setTimeout(check, this.config.enqueueDeferDelay);\n        });\n    }\n    // Batches together queued items, calls the process method.\n    // Will do nothing if the config requirements aren't met.\n    check() {\n        if (this.limiter.size > 0) {\n            // Already being checked.\n            return;\n        }\n        // We're using p-limit to ensure that multiple process calls can't be called at once.\n        this.limiter.enqueue(this._check.bind(this)).catch((err) => {\n            // This should be \"impossible\".. right?\n            this.dispatchEvent(new ErrorEvent(err));\n        });\n    }\n    // The actual implementation of the check method.\n    _check() {\n        const retry = this.check.bind(this);\n        // Get a batch of items to process.\n        const batch = this.getBatch();\n        // Nothing in the queue ready to be processed.\n        if (batch.length < 1) {\n            return Promise.resolve();\n        }\n        // Update the items that we're about to process, so they don't get double processed.\n        batch.forEach((item) => {\n            item.attempt += 1;\n            item.retryAfter = Infinity;\n        });\n        setTimeout(async () => {\n            try {\n                await this.concurrencyHandler.enqueue(this.process.bind(this, batch));\n            }\n            catch (err) {\n                this.dispatchEvent(new ErrorEvent(err));\n            }\n            finally {\n                batch.forEach((item) => {\n                    if (item.completed) {\n                        // Item completed its processing, nothing more to do.\n                        return;\n                    }\n                    else if (item.retryAfter > 0 && item.retryAfter !== Infinity) {\n                        // The item failed to process, but it is going to be retried.\n                        return;\n                    }\n                    else {\n                        // Item neither rejected, or completed its processing status.\n                        // This is a requirement, so we reject the item.\n                        item.reject(new Error('Item was not marked as resolved or rejected after batch processing completed.'));\n                    }\n                });\n                // Now that we've finished processing the batch, run the process again, just in case there's anything left.\n                setTimeout(retry, 0);\n            }\n        }, 0);\n        if (batch.length >= this.config.maxSize) {\n            // We have the maximum number of items in the batch, let's make sure we kick off the process call again.\n            setTimeout(retry, this.config.minimumDelay);\n        }\n        return Promise.resolve();\n    }\n    getBatch() {\n        const now = performance.now();\n        const batch = [];\n        for (let i = 0; i < this.queueArray.length; i++) {\n            const batchItem = this.queueArray[i];\n            if (batchItem.retryAfter > now) {\n                // Item is not ready to be retried, or it is currently being processed.\n                continue;\n            }\n            batch.push(batchItem);\n            if (batch.length >= this.config.maxSize) {\n                break;\n            }\n        }\n        return batch;\n    }\n    // Obtains a unique key to identify the item.\n    // This is used to deduplicate the batched items.\n    getKey(item) {\n        return item === undefined ? 'undefined' : JSON.stringify(item);\n    }\n    // Returns how long to wait before retrying the item.\n    getRetryDelay(item) {\n        return 0;\n    }\n    // Called when it is time to process a batch of items.\n    process(items) {\n        return Promise.reject(new Error('Inherit this class, and implement the processBatch method.'));\n    }\n}\nexport default Batch;\n","// An event class which can be used to emit an error.\nclass ErrorEvent extends Event {\n    // The error associated with the event.\n    error;\n    // Constructs the event from the error.\n    constructor(error) {\n        super('error');\n        this.error = error;\n    }\n}\nexport default ErrorEvent;\n","import ErrorEvent from './errorEvent';\n// An event class which can be used to emit an error event for an item that failed to process.\nclass ItemErrorEvent extends ErrorEvent {\n    // The item that failed to process.\n    batchItem;\n    // The amount of time when the item will be retried.\n    retryAfter;\n    // Constructs the event from the error.\n    constructor(error, batchItem, retryAfter) {\n        super(error);\n        this.batchItem = batchItem;\n        this.retryAfter = retryAfter;\n    }\n}\nexport default ItemErrorEvent;\n","// Export all the things from this module.\nexport { default as Batch } from './batch';\nexport { default as ErrorEvent } from './events/errorEvent';\nexport { default as ItemErrorEvent } from './events/itemErrorEvent';\nexport { default as PromiseQueue } from './promise-queue';\n","// A limiter for running promises in parallel.\n// Queue ensures order is maintained.\nclass PromiseQueue {\n    // All the promises that have been enqueued, and are waiting to be processed.\n    queue = [];\n    // The PromiseQueue configuration.\n    config;\n    // How many promises are actively being processed.\n    activeCount = 0;\n    // The next time a promise can be processed.\n    nextProcessTime = 0;\n    // Constructs a promise queue, defining the number of promises that may run in parallel.\n    constructor(config) {\n        this.config = config;\n    }\n    // The number of promises waiting to be processed.\n    get size() {\n        return this.queue.length;\n    }\n    // Puts a function that will create the promise to run on the queue, and returns a promise\n    // that will return the result of the enqueued promise.\n    enqueue(createPromise) {\n        return new Promise(async (resolve, reject) => {\n            this.queue.push({\n                deferredPromise: { resolve, reject },\n                createPromise,\n            });\n            await this.process();\n        });\n    }\n    async process() {\n        if (this.activeCount >= this.config.levelOfParallelism) {\n            // Already running max number of promises in parallel.\n            return;\n        }\n        const reprocess = this.process.bind(this);\n        const delayInMilliseconds = this.config.delayInMilliseconds;\n        if (delayInMilliseconds !== undefined && delayInMilliseconds > 0) {\n            const now = performance.now();\n            const remainingTime = this.nextProcessTime - now;\n            if (remainingTime > 0) {\n                // We're not allowed to process the next promise yet.\n                setTimeout(reprocess, remainingTime);\n                return;\n            }\n            this.nextProcessTime = now + delayInMilliseconds;\n        }\n        const promise = this.queue.shift();\n        if (!promise) {\n            // No promise to process.\n            return;\n        }\n        this.activeCount++;\n        try {\n            const result = await promise.createPromise();\n            promise.deferredPromise.resolve(result);\n        }\n        catch (err) {\n            promise.deferredPromise.reject(err);\n        }\n        finally {\n            // Ensure we subtract from how many promises are active\n            this.activeCount--;\n            // And then run the process function again, in case there are any promises left to run.\n            setTimeout(reprocess, 0);\n        }\n    }\n}\nexport default PromiseQueue;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { load as loadUserInfo, populate as populateUserInfo, } from './user-info';\nconst load = async () => {\n    if (!document.body) {\n        // No body yet... try again.\n        setTimeout(load, 1);\n        return;\n    }\n    document.body.setAttribute('data-extension-id', chrome.runtime.id);\n    const userInfo = await loadUserInfo();\n    populateUserInfo(userInfo);\n};\nload();\n"],"names":[],"sourceRoot":""}