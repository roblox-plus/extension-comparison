{"version":3,"file":"./service-worker.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA","sources":["webpack://roblox-plus/./src/js/constants/index.ts","webpack://roblox-plus/./src/js/services/inventoryService.ts","webpack://roblox-plus/./src/js/services/localizationService.ts","webpack://roblox-plus/./src/js/services/messageService.ts","webpack://roblox-plus/./src/js/services/settingsService.ts","webpack://roblox-plus/./src/js/utils/xsrfFetch.ts","webpack://roblox-plus/webpack/bootstrap","webpack://roblox-plus/webpack/runtime/define property getters","webpack://roblox-plus/webpack/runtime/hasOwnProperty shorthand","webpack://roblox-plus/webpack/runtime/make namespace object","webpack://roblox-plus/./src/js/service-worker/index.ts"],"sourcesContent":["const manifest = chrome.runtime.getManifest();\nconst isBackgroundPage = chrome.runtime.getURL(manifest.background?.page || '') === location.href;\nexport { manifest, isBackgroundPage };\n","import xsrfFetch from '../utils/xsrfFetch';\n// Removes an asset from the authenticated user's inventory.\nconst deleteAsset = async (assetId) => {\n    const response = await xsrfFetch(new URL(`https://assetgame.roblox.com/asset/delete-from-inventory`), {\n        method: 'POST',\n        body: JSON.stringify({\n            assetId: assetId,\n        }),\n    });\n    if (!response.ok) {\n        throw new Error(`Failed to remove asset (${assetId})`);\n    }\n};\nglobalThis.inventoryService = { deleteAsset };\nexport { deleteAsset };\n","import { addListener, sendMessage } from './messageService';\nconst englishLocale = 'en_us';\nconst messageDestination = 'localizationService.getTranslationResources';\nlet translationResourceCache = [];\nlet localeCache = '';\n// Gets the locale for the authenticated user.\nconst getAuthenticatedUserLocale = async () => {\n    if (localeCache) {\n        return localeCache;\n    }\n    try {\n        const response = await fetch(`https://locale.roblox.com/v1/locales/user-locale`);\n        if (!response.ok) {\n            console.warn('Failed to fetch user locale - defaulting to English.', response.status);\n            return (localeCache = englishLocale);\n        }\n        const result = await response.json();\n        return (localeCache = result.supportedLocale.locale);\n    }\n    catch (e) {\n        console.warn('Unhandled error loading user locale - defaulting to English.', e);\n        return (localeCache = englishLocale);\n    }\n};\n// Fetches all the translation resources for the authenticated user.\nconst getTranslationResources = async () => {\n    if (translationResourceCache.length > 0) {\n        return translationResourceCache;\n    }\n    return (translationResourceCache = await sendMessage(messageDestination, {}));\n};\n// Fetches an individual translation resource.\nconst getTranslationResource = async (namespace, key) => {\n    const translationResources = await getTranslationResources();\n    const resource = translationResources.find((r) => r.namespace === namespace && r.key === key);\n    if (!resource) {\n        console.warn(`No translation resource available.\\n\\tNamespace: ${namespace}\\n\\tKey: ${key}`);\n    }\n    return resource?.value || '';\n};\n// Listener to ensure these always happen in the background, for strongest caching potential.\naddListener(messageDestination, async () => {\n    if (translationResourceCache.length > 0) {\n        return translationResourceCache;\n    }\n    const locale = await getAuthenticatedUserLocale();\n    const response = await fetch(`https://translations.roblox.com/v1/translations?consumerType=Web`);\n    if (!response.ok) {\n        throw new Error(`Failed to load translation resources (${response.status})`);\n    }\n    const result = await response.json();\n    const resourcesUrl = result.data.find((r) => r.locale === locale) ||\n        result.data.find((r) => r.locale === englishLocale);\n    if (!resourcesUrl) {\n        throw new Error(`Failed to find translation resources for locale (${locale})`);\n    }\n    const resources = await fetch(resourcesUrl.url);\n    const resourcesJson = await resources.json();\n    return (translationResourceCache = resourcesJson.contents.map((r) => {\n        return {\n            namespace: r.namespace,\n            key: r.key,\n            value: r.translation || r.english,\n        };\n    }));\n}, {\n    // Ensure that multiple requests for this information can't be processed at once.\n    levelOfParallelism: 1,\n});\nglobalThis.localizationService = { getTranslationResource };\nexport { getTranslationResource };\n","import { isBackgroundPage } from '../constants';\n// All the listeners, set in the background page.\nconst listeners = {};\n// An identifier that tells us which version of the messaging service we're using,\n// to ensure we don't try to process a message not intended for us.\nconst version = 2.5;\n// Send a message to a destination, and get back the result.\nconst sendMessage = async (destination, message) => {\n    return new Promise(async (resolve, reject) => {\n        const serializedMessage = JSON.stringify(message);\n        if (isBackgroundPage) {\n            // Message is from the background page, to the background page.\n            try {\n                if (listeners[destination]) {\n                    const message = JSON.parse(serializedMessage);\n                    const result = await listeners[destination](message);\n                    console.debug(`Local listener response for '${destination}':`, result, message);\n                    const data = result.data === undefined ? undefined : JSON.parse(result.data);\n                    if (result.success) {\n                        resolve(data);\n                    }\n                    else {\n                        reject(data);\n                    }\n                }\n                else {\n                    reject(`No message listener: ${destination}`);\n                }\n            }\n            catch (e) {\n                reject(e);\n            }\n        }\n        else {\n            const outboundMessage = JSON.stringify({\n                version,\n                destination,\n                message: serializedMessage,\n            });\n            console.debug(`Sending message to '${destination}'`, serializedMessage);\n            chrome.runtime.sendMessage(outboundMessage, (result) => {\n                if (result === undefined) {\n                    reject(`Unexpected message result (undefined), suggests no listener in background page.\\n\\tDestination: ${destination}`);\n                    return;\n                }\n                const data = result.data === undefined ? undefined : JSON.parse(result.data);\n                if (result.success) {\n                    resolve(data);\n                }\n                else {\n                    reject(data);\n                }\n            });\n        }\n    });\n};\n// Listen for messages at a specific destination.\nconst addListener = (destination, listener, options = {\n    levelOfParallelism: -1,\n}) => {\n    if (listeners[destination]) {\n        throw new Error(`${destination} already has message listener attached`);\n    }\n    const processMessage = async (message) => {\n        try {\n            console.debug(`Processing message for '${destination}'`, message);\n            const result = await listener(message);\n            const response = {\n                success: true,\n                data: JSON.stringify(result),\n            };\n            console.debug(`Successful message result from '${destination}':`, response, message);\n            return response;\n        }\n        catch (err) {\n            const response = {\n                success: false,\n                data: JSON.stringify(err),\n            };\n            console.debug(`Failed message result from '${destination}':`, response, message, err);\n            return response;\n        }\n    };\n    listeners[destination] = (message) => {\n        if (options.levelOfParallelism !== 1) {\n            return processMessage(message);\n        }\n        return new Promise(async (resolve, reject) => {\n            // https://stackoverflow.com/a/73482349/1663648\n            await navigator.locks.request(`messageService:${destination}`, async () => {\n                try {\n                    const result = await processMessage(message);\n                    resolve(result);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    };\n};\n// If we're currently in the background page, listen for messages.\nif (isBackgroundPage) {\n    chrome.runtime.onMessage.addListener((rawMessage, sender, sendResponse) => {\n        if (typeof rawMessage !== 'string') {\n            // Not for us.\n            return;\n        }\n        const fullMessage = JSON.parse(rawMessage);\n        if (fullMessage.version !== version ||\n            !fullMessage.destination ||\n            !fullMessage.message) {\n            // Not for us.\n            return;\n        }\n        const listener = listeners[fullMessage.destination];\n        if (!listener) {\n            sendResponse({\n                success: false,\n                data: JSON.stringify(`Could not route message to destination: ${fullMessage.destination}`),\n            });\n            return;\n        }\n        const message = JSON.parse(fullMessage.message);\n        listener(message)\n            .then(sendResponse)\n            .catch((err) => {\n            console.error('Listener is never expected to throw.', err, rawMessage, fullMessage);\n            sendResponse({\n                success: false,\n                data: JSON.stringify('Listener threw unhandled exception (see background page for error).'),\n            });\n        });\n        // Required for asynchronous callbacks\n        // https://stackoverflow.com/a/20077854/1663648\n        return true;\n    });\n}\nelse {\n    console.debug(`Not attaching listener for messages, because we're not in the background.`);\n}\nglobalThis.messageService = { sendMessage, addListener };\nexport { sendMessage, addListener };\n","import { sendMessage, addListener } from './messageService';\n// Destination to be used with messaging.\nconst messageDestinationPrefix = 'settingsService';\n// Fetches a locally stored setting value by its key.\nconst getSettingValue = (key) => {\n    return sendMessage(`${messageDestinationPrefix}.getSettingValue`, {\n        key,\n    });\n};\n// Gets a boolean setting value, toggled to false by default.\nconst getToggleSettingValue = async (key) => {\n    const value = await getSettingValue(key);\n    return !!value;\n};\n// Locally stores a setting value.\nconst setSettingValue = (key, value) => {\n    return sendMessage(`${messageDestinationPrefix}.setSettingValue`, {\n        key,\n        value,\n    });\n};\nconst getValueFromLocalStorage = (key) => {\n    if (!localStorage.hasOwnProperty(key)) {\n        return undefined;\n    }\n    try {\n        const valueArray = JSON.parse(localStorage[key]);\n        if (Array.isArray(valueArray) && valueArray.length > 0) {\n            return valueArray[0];\n        }\n        console.warn(`Setting value in localStorage invalid: ${localStorage[key]} - removing it.`);\n        localStorage.removeItem(key);\n        return undefined;\n    }\n    catch (err) {\n        console.warn(`Failed to parse '${key}' value from localStorage - removing it.`, err);\n        localStorage.removeItem(key);\n        return undefined;\n    }\n};\naddListener(`${messageDestinationPrefix}.getSettingValue`, ({ key }) => {\n    return new Promise((resolve, reject) => {\n        // chrome.storage APIs are callback-based until manifest V3.\n        // Currently in migration phase, to migrate settings from localStorage -> chrome.storage.local\n        const value = getValueFromLocalStorage(key);\n        if (value !== undefined) {\n            chrome.storage.local.set({\n                [key]: value,\n            }, () => {\n                localStorage.removeItem(key);\n                resolve(value);\n            });\n        }\n        else {\n            chrome.storage.local.get(key, (values) => {\n                resolve(values[key]);\n            });\n        }\n    });\n});\naddListener(`${messageDestinationPrefix}.setSettingValue`, ({ key, value }) => {\n    return new Promise((resolve, reject) => {\n        // chrome.storage APIs are callback-based until manifest V3.\n        // Currently in migration phase, to migrate settings from localStorage -> chrome.storage.local\n        if (value === undefined) {\n            chrome.storage.local.remove(key, () => {\n                localStorage.removeItem(key);\n                resolve(undefined);\n            });\n        }\n        else {\n            chrome.storage.local.set({\n                [key]: value,\n            }, () => {\n                localStorage.removeItem(key);\n                resolve(undefined);\n            });\n        }\n    });\n});\nglobalThis.settingsService = { getSettingValue, getToggleSettingValue, setSettingValue };\nexport { getSettingValue, getToggleSettingValue, setSettingValue };\n","const headerName = 'X-CSRF-Token';\nlet xsrfToken = '';\n// A fetch request which will attach an X-CSRF-Token in all outbound requests.\nconst xsrfFetch = async (url, requestDetails) => {\n    if (url.hostname.endsWith('.roblox.com')) {\n        if (!requestDetails) {\n            requestDetails = {};\n        }\n        requestDetails.credentials = 'include';\n        if (!requestDetails.headers) {\n            requestDetails.headers = new Headers();\n        }\n        if (requestDetails.headers instanceof Headers) {\n            if (xsrfToken) {\n                requestDetails.headers.set(headerName, xsrfToken);\n            }\n            if (requestDetails.body && !requestDetails.headers.has('Content-Type')) {\n                requestDetails.headers.set('Content-Type', 'application/json');\n            }\n        }\n    }\n    const response = await fetch(url, requestDetails);\n    const token = response.headers.get(headerName);\n    if (response.ok || !token) {\n        return response;\n    }\n    xsrfToken = token;\n    return xsrfFetch(url, requestDetails);\n};\nexport default xsrfFetch;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export * as inventoryService from '../services/inventoryService';\nexport * as localizationService from '../services/localizationService';\nexport * as messageService from '../services/messageService';\nexport * as settingsService from '../services/settingsService';\n// Currently exclusively populated by build hook (see build directory).\n"],"names":[],"sourceRoot":""}