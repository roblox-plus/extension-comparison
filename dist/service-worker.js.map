{"version":3,"file":"./service-worker.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://roblox-plus/./src/js/constants/index.ts","webpack://roblox-plus/./src/js/enums/presenceType.ts","webpack://roblox-plus/./src/js/services/badges/batchProcessor.ts","webpack://roblox-plus/./src/js/services/badges/index.ts","webpack://roblox-plus/./src/js/services/inventory/index.ts","webpack://roblox-plus/./src/js/services/inventory/limitedInventory.ts","webpack://roblox-plus/./src/js/services/localization/index.ts","webpack://roblox-plus/./src/js/services/message/index.ts","webpack://roblox-plus/./src/js/services/presence/batchProcessor.ts","webpack://roblox-plus/./src/js/services/presence/index.ts","webpack://roblox-plus/./src/js/services/settings/index.ts","webpack://roblox-plus/./src/js/utils/expireableDictionary.ts","webpack://roblox-plus/./src/js/utils/wait.ts","webpack://roblox-plus/./src/js/utils/xsrfFetch.ts","webpack://roblox-plus/./node_modules/@tix-factory/batch/dist/batch/index.js","webpack://roblox-plus/./node_modules/@tix-factory/batch/dist/events/errorEvent.js","webpack://roblox-plus/./node_modules/@tix-factory/batch/dist/events/itemErrorEvent.js","webpack://roblox-plus/./node_modules/@tix-factory/batch/dist/index.js","webpack://roblox-plus/./node_modules/@tix-factory/batch/dist/promise-queue/index.js","webpack://roblox-plus/webpack/bootstrap","webpack://roblox-plus/webpack/runtime/define property getters","webpack://roblox-plus/webpack/runtime/hasOwnProperty shorthand","webpack://roblox-plus/webpack/runtime/make namespace object","webpack://roblox-plus/./src/js/service-worker/index.ts"],"sourcesContent":["const manifest = chrome.runtime.getManifest();\nconst isBackgroundPage = chrome.runtime.getURL(manifest.background?.page || '') === location.href;\nexport { manifest, isBackgroundPage };\n","// The types of user presence.\nvar PresenceType;\n(function (PresenceType) {\n    // The user is offline.\n    PresenceType[\"Offline\"] = \"Offline\";\n    // The user is online.\n    PresenceType[\"Online\"] = \"Online\";\n    // The user is currently in an experience.\n    PresenceType[\"Experience\"] = \"Experience\";\n    // The user is currently in Roblox Studio.\n    PresenceType[\"Studio\"] = \"Studio\";\n})(PresenceType || (PresenceType = {}));\nexport default PresenceType;\n","import { Batch } from '@tix-factory/batch';\nclass BadgeAwardBatchProcessor extends Batch {\n    constructor() {\n        super({\n            levelOfParallelism: 1,\n            maxSize: 100,\n            minimumDelay: 1 * 1000,\n            enqueueDeferDelay: 10,\n        });\n    }\n    async process(items) {\n        const response = await fetch(`https://badges.roblox.com/v1/users/${items[0].value.userId}/badges/awarded-dates?badgeIds=${items\n            .map((i) => i.value.badgeId)\n            .join(',')}`);\n        if (!response.ok) {\n            throw new Error('Failed to load user presence');\n        }\n        const result = await response.json();\n        items.forEach((item) => {\n            const badgeAward = result.data.find((b) => b.badgeId === item.value.badgeId);\n            if (badgeAward?.awardedDate) {\n                item.resolve(new Date(badgeAward.awardedDate));\n            }\n            else {\n                item.resolve(undefined);\n            }\n        });\n    }\n    getBatch() {\n        const now = performance.now();\n        const batch = [];\n        for (let i = 0; i < this.queueArray.length; i++) {\n            const batchItem = this.queueArray[i];\n            if (batchItem.retryAfter > now) {\n                // retryAfter is set at Infinity while the item is being processed\n                // so we should always check it, even if we're not retrying items\n                continue;\n            }\n            if (batch.length < 1 ||\n                batch[0].value.userId === batchItem.value.userId) {\n                // We group all the requests for badge award dates together by user ID.\n                batch.push(batchItem);\n            }\n            if (batch.length >= this.config.maxSize) {\n                // We have all the items we need, break.\n                break;\n            }\n        }\n        return batch;\n    }\n    getKey(item) {\n        return `${item.userId}:${item.badgeId}`;\n    }\n}\nexport default BadgeAwardBatchProcessor;\n","import ExpirableDictionary from '../../utils/expireableDictionary';\nimport { addListener, sendMessage } from '../message';\nimport BadgeAwardBatchProcessor from './batchProcessor';\nconst messageDestination = 'badgesService.getBadgeAwardDate';\nconst badgeAwardProcessor = new BadgeAwardBatchProcessor();\nconst badgeAwardCache = new ExpirableDictionary('badgesService', 60 * 1000);\n// Fetches the presence for a user.\nconst getBadgeAwardDate = async (userId, badgeId) => {\n    const date = await sendMessage(messageDestination, {\n        userId,\n        badgeId,\n    });\n    return date ? new Date(date) : undefined;\n};\n// Listen for messages of things trying to fetch presence.\naddListener(messageDestination, (message) => {\n    // Check the cache\n    return badgeAwardCache.getOrAdd(badgeAwardProcessor.getKey(message), async () => {\n        // Queue up the fetch request, when not in the cache\n        const date = await badgeAwardProcessor.enqueue(message);\n        return date?.getTime();\n    });\n});\nglobalThis.badgesService = { getBadgeAwardDate };\nexport { getBadgeAwardDate };\n","import xsrfFetch from '../../utils/xsrfFetch';\nimport { default as getLimitedInventory } from './limitedInventory';\n// Removes an asset from the authenticated user's inventory.\nconst deleteAsset = async (assetId) => {\n    const response = await xsrfFetch(new URL(`https://assetgame.roblox.com/asset/delete-from-inventory`), {\n        method: 'POST',\n        body: JSON.stringify({\n            assetId: assetId,\n        }),\n    });\n    if (!response.ok) {\n        throw new Error(`Failed to remove asset (${assetId})`);\n    }\n};\nglobalThis.inventoryService = { deleteAsset, getLimitedInventory };\nexport { deleteAsset, getLimitedInventory };\n","import ExpirableDictionary from '../../utils/expireableDictionary';\nimport wait from '../../utils/wait';\nimport { addListener, sendMessage } from '../message';\nconst messageDestination = 'inventoryService.getLimitedInventory';\nconst cache = new ExpirableDictionary(messageDestination, 5 * 60 * 1000);\n// Fetches the limited inventory for the specified user.\nconst getLimitedInventory = (userId) => {\n    return sendMessage(messageDestination, {\n        userId,\n    });\n};\n// Actually loads the inventory.\nconst loadLimitedInventory = async (userId) => {\n    const foundUserAssetIds = new Set();\n    const limitedAssets = [];\n    let nextPageCursor = '';\n    do {\n        const response = await fetch(`https://inventory.roblox.com/v1/users/${userId}/assets/collectibles?limit=100&cursor=${nextPageCursor}`);\n        if (response.status === 429) {\n            // Throttled. Wait a few seconds, and try again.\n            await wait(5000);\n            continue;\n        }\n        else if (response.status === 403) {\n            throw new Error('Inventory hidden');\n        }\n        else if (!response.ok) {\n            throw new Error('Inventory failed to load');\n        }\n        const result = await response.json();\n        nextPageCursor = result.nextPageCursor;\n        result.data.forEach((item) => {\n            const userAssetId = Number(item.userAssetId);\n            if (foundUserAssetIds.has(userAssetId)) {\n                return;\n            }\n            foundUserAssetIds.add(userAssetId);\n            limitedAssets.push({\n                userAssetId,\n                id: item.assetId,\n                name: item.name,\n                recentAveragePrice: item.recentAveragePrice\n                    ? Number(item.recentAveragePrice)\n                    : NaN,\n                serialNumber: item.serialNumber ? Number(item.serialNumber) : NaN,\n                stock: item.assetStock === 0 ? 0 : item.assetStock || undefined,\n            });\n        });\n    } while (nextPageCursor);\n    return limitedAssets;\n};\n// Listen for background messages\naddListener(messageDestination, (message) => {\n    // Check the cache\n    return cache.getOrAdd(`${message.userId}`, () => \n    // Queue up the fetch request, when not in the cache\n    loadLimitedInventory(message.userId));\n}, {\n    levelOfParallelism: 1,\n});\nexport default getLimitedInventory;\n","import { addListener, sendMessage } from '../message';\nconst englishLocale = 'en_us';\nconst messageDestination = 'localizationService.getTranslationResources';\nlet translationResourceCache = [];\nlet localeCache = '';\n// Gets the locale for the authenticated user.\nconst getAuthenticatedUserLocale = async () => {\n    if (localeCache) {\n        return localeCache;\n    }\n    try {\n        const response = await fetch(`https://locale.roblox.com/v1/locales/user-locale`);\n        if (!response.ok) {\n            console.warn('Failed to fetch user locale - defaulting to English.', response.status);\n            return (localeCache = englishLocale);\n        }\n        const result = await response.json();\n        return (localeCache = result.supportedLocale.locale);\n    }\n    catch (e) {\n        console.warn('Unhandled error loading user locale - defaulting to English.', e);\n        return (localeCache = englishLocale);\n    }\n};\n// Fetches all the translation resources for the authenticated user.\nconst getTranslationResources = async () => {\n    if (translationResourceCache.length > 0) {\n        return translationResourceCache;\n    }\n    return (translationResourceCache = await sendMessage(messageDestination, {}));\n};\n// Fetches an individual translation resource.\nconst getTranslationResource = async (namespace, key) => {\n    const translationResources = await getTranslationResources();\n    const resource = translationResources.find((r) => r.namespace === namespace && r.key === key);\n    if (!resource) {\n        console.warn(`No translation resource available.\\n\\tNamespace: ${namespace}\\n\\tKey: ${key}`);\n    }\n    return resource?.value || '';\n};\n// Listener to ensure these always happen in the background, for strongest caching potential.\naddListener(messageDestination, async () => {\n    if (translationResourceCache.length > 0) {\n        return translationResourceCache;\n    }\n    const locale = await getAuthenticatedUserLocale();\n    const response = await fetch(`https://translations.roblox.com/v1/translations?consumerType=Web`);\n    if (!response.ok) {\n        throw new Error(`Failed to load translation resources (${response.status})`);\n    }\n    const result = await response.json();\n    const resourcesUrl = result.data.find((r) => r.locale === locale) ||\n        result.data.find((r) => r.locale === englishLocale);\n    if (!resourcesUrl) {\n        throw new Error(`Failed to find translation resources for locale (${locale})`);\n    }\n    const resources = await fetch(resourcesUrl.url);\n    const resourcesJson = await resources.json();\n    return (translationResourceCache = resourcesJson.contents.map((r) => {\n        return {\n            namespace: r.namespace,\n            key: r.key,\n            value: r.translation || r.english,\n        };\n    }));\n}, {\n    // Ensure that multiple requests for this information can't be processed at once.\n    levelOfParallelism: 1,\n});\nglobalThis.localizationService = { getTranslationResource };\nexport { getTranslationResource };\n","import { isBackgroundPage } from '../../constants';\n// All the listeners, set in the background page.\nconst listeners = {};\n// An identifier that tells us which version of the messaging service we're using,\n// to ensure we don't try to process a message not intended for us.\nconst version = 2.5;\n// Send a message to a destination, and get back the result.\nconst sendMessage = async (destination, message) => {\n    return new Promise(async (resolve, reject) => {\n        const serializedMessage = JSON.stringify(message);\n        if (isBackgroundPage) {\n            // Message is from the background page, to the background page.\n            try {\n                if (listeners[destination]) {\n                    const message = JSON.parse(serializedMessage);\n                    const result = await listeners[destination](message);\n                    console.debug(`Local listener response for '${destination}':`, result, message);\n                    const data = result.data === undefined ? undefined : JSON.parse(result.data);\n                    if (result.success) {\n                        resolve(data);\n                    }\n                    else {\n                        reject(data);\n                    }\n                }\n                else {\n                    reject(`No message listener: ${destination}`);\n                }\n            }\n            catch (e) {\n                reject(e);\n            }\n        }\n        else {\n            const outboundMessage = JSON.stringify({\n                version,\n                destination,\n                message: serializedMessage,\n            });\n            console.debug(`Sending message to '${destination}'`, serializedMessage);\n            chrome.runtime.sendMessage(outboundMessage, (result) => {\n                if (result === undefined) {\n                    reject(`Unexpected message result (undefined), suggests no listener in background page.\\n\\tDestination: ${destination}`);\n                    return;\n                }\n                const data = result.data === undefined ? undefined : JSON.parse(result.data);\n                if (result.success) {\n                    resolve(data);\n                }\n                else {\n                    reject(data);\n                }\n            });\n        }\n    });\n};\n// Listen for messages at a specific destination.\nconst addListener = (destination, listener, options = {\n    levelOfParallelism: -1,\n}) => {\n    if (listeners[destination]) {\n        throw new Error(`${destination} already has message listener attached`);\n    }\n    const processMessage = async (message) => {\n        try {\n            console.debug(`Processing message for '${destination}'`, message);\n            const result = await listener(message);\n            const response = {\n                success: true,\n                data: JSON.stringify(result),\n            };\n            console.debug(`Successful message result from '${destination}':`, response, message);\n            return response;\n        }\n        catch (err) {\n            const response = {\n                success: false,\n                data: JSON.stringify(err),\n            };\n            console.debug(`Failed message result from '${destination}':`, response, message, err);\n            return response;\n        }\n    };\n    listeners[destination] = (message) => {\n        if (options.levelOfParallelism !== 1) {\n            return processMessage(message);\n        }\n        return new Promise((resolve, reject) => {\n            // https://stackoverflow.com/a/73482349/1663648\n            navigator.locks\n                .request(`messageService:${destination}`, async () => {\n                try {\n                    const result = await processMessage(message);\n                    resolve(result);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            })\n                .catch(reject);\n        });\n    };\n};\n// If we're currently in the background page, listen for messages.\nif (isBackgroundPage) {\n    chrome.runtime.onMessage.addListener((rawMessage, sender, sendResponse) => {\n        if (typeof rawMessage !== 'string') {\n            // Not for us.\n            return;\n        }\n        const fullMessage = JSON.parse(rawMessage);\n        if (fullMessage.version !== version ||\n            !fullMessage.destination ||\n            !fullMessage.message) {\n            // Not for us.\n            return;\n        }\n        const listener = listeners[fullMessage.destination];\n        if (!listener) {\n            sendResponse({\n                success: false,\n                data: JSON.stringify(`Could not route message to destination: ${fullMessage.destination}`),\n            });\n            return;\n        }\n        const message = JSON.parse(fullMessage.message);\n        listener(message)\n            .then(sendResponse)\n            .catch((err) => {\n            console.error('Listener is never expected to throw.', err, rawMessage, fullMessage);\n            sendResponse({\n                success: false,\n                data: JSON.stringify('Listener threw unhandled exception (see background page for error).'),\n            });\n        });\n        // Required for asynchronous callbacks\n        // https://stackoverflow.com/a/20077854/1663648\n        return true;\n    });\n}\nelse {\n    console.debug(`Not attaching listener for messages, because we're not in the background.`);\n}\nglobalThis.messageService = { sendMessage, addListener };\nexport { sendMessage, addListener };\n","import { Batch } from '@tix-factory/batch';\nimport PresenceType from '../../enums/presenceType';\nconst getPresenceType = (presenceType) => {\n    switch (presenceType) {\n        case 1:\n            return PresenceType.Online;\n        case 2:\n            return PresenceType.Experience;\n        case 3:\n            return PresenceType.Studio;\n        default:\n            return PresenceType.Offline;\n    }\n};\nconst getLocationName = (presenceType, name) => {\n    if (!name) {\n        return '';\n    }\n    if (presenceType === PresenceType.Studio) {\n        return name.replace(/^Studio\\s+-\\s*/, '');\n    }\n    return name;\n};\nclass PresenceBatchProcessor extends Batch {\n    constructor() {\n        super({\n            levelOfParallelism: 1,\n            maxSize: 100,\n            minimumDelay: 3 * 1000,\n            enqueueDeferDelay: 10,\n        });\n    }\n    async process(items) {\n        const response = await fetch('https://presence.roblox.com/v1/presence/users', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({\n                userIds: items.map((i) => i.value),\n            }),\n        });\n        if (!response.ok) {\n            throw new Error('Failed to load user presence');\n        }\n        const result = await response.json();\n        items.forEach((item) => {\n            const presence = result.userPresences.find((p) => p.userId === item.value);\n            if (presence) {\n                const presenceType = getPresenceType(presence.userPresenceType);\n                if (presence.placeId &&\n                    (presenceType === PresenceType.Experience ||\n                        presenceType === PresenceType.Studio)) {\n                    item.resolve({\n                        type: presenceType,\n                        location: {\n                            id: presence.placeId,\n                            name: getLocationName(presenceType, presence.lastLocation),\n                            serverId: presence.gameId,\n                        },\n                    });\n                }\n                else {\n                    item.resolve({\n                        type: presenceType,\n                    });\n                }\n            }\n            else {\n                item.resolve({\n                    type: PresenceType.Offline,\n                });\n            }\n        });\n    }\n}\nexport default PresenceBatchProcessor;\n","import ExpirableDictionary from '../../utils/expireableDictionary';\nimport { addListener, sendMessage } from '../message';\nimport PresenceBatchProcessor from './batchProcessor';\nconst messageDestination = 'presenceService.getUserPresence';\nconst presenceProcessor = new PresenceBatchProcessor();\nconst presenceCache = new ExpirableDictionary('presenceService', 15 * 1000);\n// Fetches the presence for a user.\nconst getUserPresence = (userId) => {\n    return sendMessage(messageDestination, { userId });\n};\n// Listen for messages of things trying to fetch presence.\naddListener(messageDestination, (message) => {\n    // Check the cache\n    return presenceCache.getOrAdd(`${message.userId}`, () => \n    // Queue up the fetch request, when not in the cache\n    presenceProcessor.enqueue(message.userId));\n});\nglobalThis.presenceService = { getUserPresence };\nexport { getUserPresence };\n","import { sendMessage, addListener } from '../message';\n// Destination to be used with messaging.\nconst messageDestinationPrefix = 'settingsService';\n// Fetches a locally stored setting value by its key.\nconst getSettingValue = (key) => {\n    return sendMessage(`${messageDestinationPrefix}.getSettingValue`, {\n        key,\n    });\n};\n// Gets a boolean setting value, toggled to false by default.\nconst getToggleSettingValue = async (key) => {\n    const value = await getSettingValue(key);\n    return !!value;\n};\n// Locally stores a setting value.\nconst setSettingValue = (key, value) => {\n    return sendMessage(`${messageDestinationPrefix}.setSettingValue`, {\n        key,\n        value,\n    });\n};\nconst getValueFromLocalStorage = (key) => {\n    if (!localStorage.hasOwnProperty(key)) {\n        return undefined;\n    }\n    try {\n        const valueArray = JSON.parse(localStorage[key]);\n        if (Array.isArray(valueArray) && valueArray.length > 0) {\n            return valueArray[0];\n        }\n        console.warn(`Setting value in localStorage invalid: ${localStorage[key]} - removing it.`);\n        localStorage.removeItem(key);\n        return undefined;\n    }\n    catch (err) {\n        console.warn(`Failed to parse '${key}' value from localStorage - removing it.`, err);\n        localStorage.removeItem(key);\n        return undefined;\n    }\n};\naddListener(`${messageDestinationPrefix}.getSettingValue`, ({ key }) => {\n    return new Promise((resolve, reject) => {\n        // chrome.storage APIs are callback-based until manifest V3.\n        // Currently in migration phase, to migrate settings from localStorage -> chrome.storage.local\n        const value = getValueFromLocalStorage(key);\n        if (value !== undefined) {\n            chrome.storage.local.set({\n                [key]: value,\n            }, () => {\n                localStorage.removeItem(key);\n                resolve(value);\n            });\n        }\n        else {\n            chrome.storage.local.get(key, (values) => {\n                resolve(values[key]);\n            });\n        }\n    });\n});\naddListener(`${messageDestinationPrefix}.setSettingValue`, ({ key, value }) => {\n    return new Promise((resolve, reject) => {\n        // chrome.storage APIs are callback-based until manifest V3.\n        // Currently in migration phase, to migrate settings from localStorage -> chrome.storage.local\n        if (value === undefined) {\n            chrome.storage.local.remove(key, () => {\n                localStorage.removeItem(key);\n                resolve(undefined);\n            });\n        }\n        else {\n            chrome.storage.local.set({\n                [key]: value,\n            }, () => {\n                localStorage.removeItem(key);\n                resolve(undefined);\n            });\n        }\n    });\n});\nglobalThis.settingsService = { getSettingValue, getToggleSettingValue, setSettingValue };\nexport { getSettingValue, getToggleSettingValue, setSettingValue };\n","// This class can be used to concurrently cache items, or fetch their values.\nclass ExpirableDictionary {\n    lockKey;\n    expirationInMilliseconds;\n    // The items that are in the dictionary.\n    items = {};\n    constructor(\n    // A name for the dictionary, used for locking.\n    name, \n    // How long the item will remain in the dictionary, in milliseconds.\n    expirationInMilliseconds) {\n        this.lockKey = `ExpirableDictionary:${name}`;\n        this.expirationInMilliseconds = expirationInMilliseconds;\n    }\n    // Tries to fetch an item by its key from the dictionary, or it will call the value factory to add it in.\n    getOrAdd(key, valueFactory) {\n        const item = this.items[key];\n        if (item !== undefined) {\n            return Promise.resolve(item);\n        }\n        return new Promise((resolve, reject) => {\n            navigator.locks\n                .request(`${this.lockKey}:${key}`, async () => {\n                // It's possible the item was added since we requested the lock, check again.\n                const item = this.items[key];\n                if (item !== undefined) {\n                    resolve(item);\n                    return;\n                }\n                try {\n                    const value = (this.items[key] = await valueFactory());\n                    setTimeout(() => {\n                        delete this.items[key];\n                    }, this.expirationInMilliseconds);\n                    resolve(value);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            })\n                .catch(reject);\n        });\n    }\n}\nexport default ExpirableDictionary;\n","export default (time) => {\n    return new Promise((resolve, reject) => {\n        setTimeout(resolve, time);\n    });\n};\n","const headerName = 'X-CSRF-Token';\nlet xsrfToken = '';\n// A fetch request which will attach an X-CSRF-Token in all outbound requests.\nconst xsrfFetch = async (url, requestDetails) => {\n    if (url.hostname.endsWith('.roblox.com')) {\n        if (!requestDetails) {\n            requestDetails = {};\n        }\n        requestDetails.credentials = 'include';\n        if (!requestDetails.headers) {\n            requestDetails.headers = new Headers();\n        }\n        if (requestDetails.headers instanceof Headers) {\n            if (xsrfToken) {\n                requestDetails.headers.set(headerName, xsrfToken);\n            }\n            if (requestDetails.body && !requestDetails.headers.has('Content-Type')) {\n                requestDetails.headers.set('Content-Type', 'application/json');\n            }\n        }\n    }\n    const response = await fetch(url, requestDetails);\n    const token = response.headers.get(headerName);\n    if (response.ok || !token) {\n        return response;\n    }\n    xsrfToken = token;\n    return xsrfFetch(url, requestDetails);\n};\nexport default xsrfFetch;\n","import PromiseQueue from '../promise-queue';\nimport ErrorEvent from '../events/errorEvent';\nimport ItemErrorEvent from '../events/itemErrorEvent';\n// A class for batching and processing multiple single items into a single call.\nclass Batch extends EventTarget {\n    queueMap = {};\n    promiseMap = {};\n    limiter;\n    concurrencyHandler;\n    // All the batch items waiting to be processed.\n    queueArray = [];\n    // The configuration for this batch processor.\n    config;\n    constructor(configuration) {\n        super();\n        this.config = configuration;\n        this.limiter = new PromiseQueue({\n            levelOfParallelism: 1,\n            delayInMilliseconds: configuration.minimumDelay || 0,\n        });\n        this.concurrencyHandler = new PromiseQueue({\n            levelOfParallelism: configuration.levelOfParallelism || Infinity,\n        });\n    }\n    // Enqueues an item into a batch, to be processed.\n    enqueue(item) {\n        return new Promise((resolve, reject) => {\n            const key = this.getKey(item);\n            const promiseMap = this.promiseMap;\n            const queueArray = this.queueArray;\n            const queueMap = this.queueMap;\n            const retryCount = this.config.retryCount || 0;\n            const getRetryDelay = this.getRetryDelay.bind(this);\n            const dispatchEvent = this.dispatchEvent.bind(this);\n            const check = this.check.bind(this);\n            // Step 1: Ensure we have a way to resolve/reject the promise for this item.\n            const mergedPromise = promiseMap[key] || [];\n            if (mergedPromise.length < 0) {\n                this.promiseMap[key] = mergedPromise;\n            }\n            mergedPromise.push({ resolve, reject });\n            // Step 2: Check if we have the batched item created.\n            if (!queueMap[key]) {\n                const remove = (item) => {\n                    // Mark the item as completed, so we know we either resolved or rejected it.\n                    item.completed = true;\n                    for (let i = 0; i < queueArray.length; i++) {\n                        if (queueArray[i].key === key) {\n                            queueArray.splice(i, 1);\n                            break;\n                        }\n                    }\n                    delete promiseMap[key];\n                    delete queueMap[key];\n                };\n                const batchItem = {\n                    key,\n                    value: item,\n                    attempt: 0,\n                    retryAfter: 0,\n                    completed: false,\n                    resolve(result) {\n                        // We're not accepting any new items for this resolution.\n                        remove(this);\n                        // Defer the resolution until after the thread resolves.\n                        setTimeout(() => {\n                            // Process anyone who applied.\n                            while (mergedPromise.length > 0) {\n                                const promise = mergedPromise.shift();\n                                promise?.resolve(result);\n                            }\n                        }, 0);\n                    },\n                    reject(error) {\n                        // Defer the resolution until after the thread resolves.\n                        const retryDelay = this.attempt <= retryCount ? getRetryDelay(this) : undefined;\n                        const retryAfter = retryDelay !== undefined\n                            ? performance.now() + retryDelay\n                            : undefined;\n                        // Emit an event to notify that the item failed to process.\n                        dispatchEvent(new ItemErrorEvent(error, this, retryAfter));\n                        if (retryAfter !== undefined) {\n                            // The item can be retried, we haven't hit the maximum number of attempts yet.\n                            this.retryAfter = retryAfter;\n                            // Ensure the check runs after the retry delay.\n                            setTimeout(check, retryDelay);\n                        }\n                        else {\n                            // Remove the item, and reject anyone waiting on it.\n                            remove(this);\n                            // Defer the resolution until after the thread resolves.\n                            setTimeout(() => {\n                                // Process anyone who applied.\n                                while (mergedPromise.length > 0) {\n                                    const promise = mergedPromise.shift();\n                                    promise?.reject(error);\n                                }\n                            }, 0);\n                        }\n                    },\n                };\n                queueMap[key] = batchItem;\n                queueArray.push(batchItem);\n            }\n            // Attempt to process the queue on the next event loop.\n            setTimeout(check, this.config.enqueueDeferDelay);\n        });\n    }\n    // Batches together queued items, calls the process method.\n    // Will do nothing if the config requirements aren't met.\n    check() {\n        if (this.limiter.size > 0) {\n            // Already being checked.\n            return;\n        }\n        // We're using p-limit to ensure that multiple process calls can't be called at once.\n        this.limiter.enqueue(this._check.bind(this)).catch((err) => {\n            // This should be \"impossible\".. right?\n            this.dispatchEvent(new ErrorEvent(err));\n        });\n    }\n    // The actual implementation of the check method.\n    _check() {\n        const retry = this.check.bind(this);\n        // Get a batch of items to process.\n        const batch = this.getBatch();\n        // Nothing in the queue ready to be processed.\n        if (batch.length < 1) {\n            return Promise.resolve();\n        }\n        // Update the items that we're about to process, so they don't get double processed.\n        batch.forEach((item) => {\n            item.attempt += 1;\n            item.retryAfter = Infinity;\n        });\n        setTimeout(async () => {\n            try {\n                await this.concurrencyHandler.enqueue(this.process.bind(this, batch));\n            }\n            catch (err) {\n                this.dispatchEvent(new ErrorEvent(err));\n            }\n            finally {\n                batch.forEach((item) => {\n                    if (item.completed) {\n                        // Item completed its processing, nothing more to do.\n                        return;\n                    }\n                    else if (item.retryAfter > 0 && item.retryAfter !== Infinity) {\n                        // The item failed to process, but it is going to be retried.\n                        return;\n                    }\n                    else {\n                        // Item neither rejected, or completed its processing status.\n                        // This is a requirement, so we reject the item.\n                        item.reject(new Error('Item was not marked as resolved or rejected after batch processing completed.'));\n                    }\n                });\n                // Now that we've finished processing the batch, run the process again, just in case there's anything left.\n                setTimeout(retry, 0);\n            }\n        }, 0);\n        if (batch.length >= this.config.maxSize) {\n            // We have the maximum number of items in the batch, let's make sure we kick off the process call again.\n            setTimeout(retry, this.config.minimumDelay);\n        }\n        return Promise.resolve();\n    }\n    getBatch() {\n        const now = performance.now();\n        const batch = [];\n        for (let i = 0; i < this.queueArray.length; i++) {\n            const batchItem = this.queueArray[i];\n            if (batchItem.retryAfter > now) {\n                // Item is not ready to be retried, or it is currently being processed.\n                continue;\n            }\n            batch.push(batchItem);\n            if (batch.length >= this.config.maxSize) {\n                break;\n            }\n        }\n        return batch;\n    }\n    // Obtains a unique key to identify the item.\n    // This is used to deduplicate the batched items.\n    getKey(item) {\n        return item === undefined ? 'undefined' : JSON.stringify(item);\n    }\n    // Returns how long to wait before retrying the item.\n    getRetryDelay(item) {\n        return 0;\n    }\n    // Called when it is time to process a batch of items.\n    process(items) {\n        return Promise.reject(new Error('Inherit this class, and implement the processBatch method.'));\n    }\n}\nexport default Batch;\n","// An event class which can be used to emit an error.\nclass ErrorEvent extends Event {\n    // The error associated with the event.\n    error;\n    // Constructs the event from the error.\n    constructor(error) {\n        super('error');\n        this.error = error;\n    }\n}\nexport default ErrorEvent;\n","import ErrorEvent from './errorEvent';\n// An event class which can be used to emit an error event for an item that failed to process.\nclass ItemErrorEvent extends ErrorEvent {\n    // The item that failed to process.\n    batchItem;\n    // The amount of time when the item will be retried.\n    retryAfter;\n    // Constructs the event from the error.\n    constructor(error, batchItem, retryAfter) {\n        super(error);\n        this.batchItem = batchItem;\n        this.retryAfter = retryAfter;\n    }\n}\nexport default ItemErrorEvent;\n","// Export all the things from this module.\nexport { default as Batch } from './batch';\nexport { default as ErrorEvent } from './events/errorEvent';\nexport { default as ItemErrorEvent } from './events/itemErrorEvent';\nexport { default as PromiseQueue } from './promise-queue';\n","// A limiter for running promises in parallel.\n// Queue ensures order is maintained.\nclass PromiseQueue {\n    // All the promises that have been enqueued, and are waiting to be processed.\n    queue = [];\n    // The PromiseQueue configuration.\n    config;\n    // How many promises are actively being processed.\n    activeCount = 0;\n    // The next time a promise can be processed.\n    nextProcessTime = 0;\n    // Constructs a promise queue, defining the number of promises that may run in parallel.\n    constructor(config) {\n        this.config = config;\n    }\n    // The number of promises waiting to be processed.\n    get size() {\n        return this.queue.length;\n    }\n    // Puts a function that will create the promise to run on the queue, and returns a promise\n    // that will return the result of the enqueued promise.\n    enqueue(createPromise) {\n        return new Promise(async (resolve, reject) => {\n            this.queue.push({\n                deferredPromise: { resolve, reject },\n                createPromise,\n            });\n            await this.process();\n        });\n    }\n    async process() {\n        if (this.activeCount >= this.config.levelOfParallelism) {\n            // Already running max number of promises in parallel.\n            return;\n        }\n        const reprocess = this.process.bind(this);\n        const delayInMilliseconds = this.config.delayInMilliseconds;\n        if (delayInMilliseconds !== undefined && delayInMilliseconds > 0) {\n            const now = performance.now();\n            const remainingTime = this.nextProcessTime - now;\n            if (remainingTime > 0) {\n                // We're not allowed to process the next promise yet.\n                setTimeout(reprocess, remainingTime);\n                return;\n            }\n            this.nextProcessTime = now + delayInMilliseconds;\n        }\n        const promise = this.queue.shift();\n        if (!promise) {\n            // No promise to process.\n            return;\n        }\n        this.activeCount++;\n        try {\n            const result = await promise.createPromise();\n            promise.deferredPromise.resolve(result);\n        }\n        catch (err) {\n            promise.deferredPromise.reject(err);\n        }\n        finally {\n            // Ensure we subtract from how many promises are active\n            this.activeCount--;\n            // And then run the process function again, in case there are any promises left to run.\n            setTimeout(reprocess, 0);\n        }\n    }\n}\nexport default PromiseQueue;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export * as badges from '../services/badges';\nexport * as inventory from '../services/inventory';\nexport * as localization from '../services/localization';\nexport * as message from '../services/message';\nexport * as presence from '../services/presence';\nexport * as settings from '../services/settings';\n// Currently exclusively populated by build hook (see build directory).\n"],"names":[],"sourceRoot":""}